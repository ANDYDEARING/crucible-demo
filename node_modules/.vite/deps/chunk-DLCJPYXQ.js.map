{
  "version": 3,
  "sources": ["../../../dev/core/src/Audio/sound.ts", "../../../dev/core/src/Audio/soundTrack.ts", "../../../dev/core/src/Loading/Plugins/babylonFileParser.function.ts", "../../../dev/core/src/Audio/audioSceneComponent.ts"],
  "sourcesContent": ["import type { IStaticSoundOptions, IStaticSoundPlayOptions, IStaticSoundStopOptions } from \"../AudioV2/abstractAudio/staticSound\";\r\nimport type { IStreamingSoundOptions } from \"../AudioV2/abstractAudio/streamingSound\";\r\nimport { _HasSpatialAudioOptions, _SpatialAudioDefaults } from \"../AudioV2/abstractAudio/subProperties/abstractSpatialAudio\";\r\nimport type { IAudioParameterRampOptions } from \"../AudioV2/audioParameter\";\r\nimport { AudioParameterRampShape } from \"../AudioV2/audioParameter\";\r\nimport { SoundState } from \"../AudioV2/soundState\";\r\nimport { _WebAudioSoundSource } from \"../AudioV2/webAudio/webAudioSoundSource\";\r\nimport { _WebAudioStaticSound } from \"../AudioV2/webAudio/webAudioStaticSound\";\r\nimport { _WebAudioStreamingSound } from \"../AudioV2/webAudio/webAudioStreamingSound\";\r\nimport { AbstractEngine } from \"../Engines/abstractEngine\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { Vector3 } from \"../Maths/math.vector\";\r\nimport type { AbstractMesh } from \"../Meshes/abstractMesh\";\r\nimport type { TransformNode } from \"../Meshes/transformNode\";\r\nimport { _WarnImport } from \"../Misc/devTools\";\r\nimport { Logger } from \"../Misc/logger\";\r\nimport { Observable } from \"../Misc/observable\";\r\nimport { _RetryWithInterval } from \"../Misc/timingTools\";\r\nimport { RegisterClass } from \"../Misc/typeStore\";\r\nimport type { Scene } from \"../scene\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { AudioEngine } from \"./audioEngine\";\r\nimport type { ISoundOptions } from \"./Interfaces/ISoundOptions\";\r\n\r\nconst TmpRampOptions: IAudioParameterRampOptions = {\r\n    duration: 0,\r\n    shape: AudioParameterRampShape.Linear,\r\n};\r\n\r\nconst TmpPlayOptions: Partial<IStaticSoundPlayOptions> = {\r\n    duration: 0,\r\n    startOffset: 0,\r\n    waitTime: 0,\r\n};\r\n\r\nconst TmpStopOptions: IStaticSoundStopOptions = {\r\n    waitTime: 0,\r\n};\r\n\r\nfunction D2r(degrees: number): number {\r\n    return (degrees * Math.PI) / 180;\r\n}\r\n\r\nfunction R2d(radians: number): number {\r\n    return (radians * 180) / Math.PI;\r\n}\r\n\r\n/**\r\n * Defines a sound that can be played in the application.\r\n * The sound can either be an ambient track or a simple sound played in reaction to a user action.\r\n * @see https://doc.babylonjs.com/legacy/audio\r\n */\r\nexport class Sound {\r\n    /**\r\n     * The name of the sound in the scene.\r\n     */\r\n    public get name(): string {\r\n        return this._soundV2.name;\r\n    }\r\n\r\n    public set name(value: string) {\r\n        this._soundV2.name = value;\r\n    }\r\n\r\n    /**\r\n     * Does the sound autoplay once loaded.\r\n     */\r\n    public get autoplay(): boolean {\r\n        return this._soundV2 instanceof _WebAudioSoundSource ? true : this._optionsV2.autoplay!;\r\n    }\r\n\r\n    public set autoplay(value: boolean) {\r\n        this._optionsV2.autoplay = value;\r\n    }\r\n\r\n    /**\r\n     * Does the sound loop after it finishes playing once.\r\n     */\r\n    public get loop(): boolean {\r\n        return this._soundV2 instanceof _WebAudioSoundSource ? true : this._soundV2.loop;\r\n    }\r\n\r\n    public set loop(value: boolean) {\r\n        if (this._soundV2 instanceof _WebAudioSoundSource) {\r\n            return;\r\n        }\r\n\r\n        if (this._soundV2) {\r\n            this._soundV2.loop = value;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Does the sound use a custom attenuation curve to simulate the falloff\r\n     * happening when the source gets further away from the camera.\r\n     * @see https://doc.babylonjs.com/legacy/audio#creating-your-own-custom-attenuation-function\r\n     */\r\n    public useCustomAttenuation: boolean = false;\r\n    /**\r\n     * The sound track id this sound belongs to.\r\n     */\r\n    public soundTrackId: number = -1;\r\n    /**\r\n     * Is this sound currently played.\r\n     */\r\n    public get isPlaying(): boolean {\r\n        return this._soundV2 instanceof _WebAudioSoundSource ? true : this._soundV2?.state === SoundState.Started || (!this.isReady() && this._optionsV2.autoplay!);\r\n    }\r\n\r\n    /**\r\n     * Is this sound currently paused.\r\n     */\r\n    public get isPaused(): boolean {\r\n        return this._soundV2 instanceof _WebAudioSoundSource ? false : this._soundV2.state === SoundState.Paused;\r\n    }\r\n\r\n    /**\r\n     * Define the reference distance the sound should be heard perfectly.\r\n     * @see https://doc.babylonjs.com/legacy/audio#creating-a-spatial-3d-sound\r\n     */\r\n    public refDistance: number = 1;\r\n    /**\r\n     * Define the roll off factor of spatial sounds.\r\n     * @see https://doc.babylonjs.com/legacy/audio#creating-a-spatial-3d-sound\r\n     */\r\n    public rolloffFactor: number = 1;\r\n    /**\r\n     * Define the max distance the sound should be heard (intensity just became 0 at this point).\r\n     * @see https://doc.babylonjs.com/legacy/audio#creating-a-spatial-3d-sound\r\n     */\r\n    public get maxDistance(): number {\r\n        return this._optionsV2.spatialMaxDistance || 100;\r\n    }\r\n    public set maxDistance(value: number) {\r\n        this._optionsV2.spatialMaxDistance = value;\r\n\r\n        if (this.useCustomAttenuation) {\r\n            return;\r\n        }\r\n\r\n        if (this._soundV2) {\r\n            this._initSpatial();\r\n            this._soundV2.spatial.maxDistance = value;\r\n        }\r\n    }\r\n    /**\r\n     * Define the distance attenuation model the sound will follow.\r\n     * @see https://doc.babylonjs.com/legacy/audio#creating-a-spatial-3d-sound\r\n     */\r\n    public get distanceModel(): \"linear\" | \"inverse\" | \"exponential\" {\r\n        return this._optionsV2.spatialDistanceModel || \"linear\";\r\n    }\r\n    public set distanceModel(value: \"linear\" | \"inverse\" | \"exponential\") {\r\n        this._optionsV2.spatialDistanceModel = value;\r\n\r\n        if (this._soundV2) {\r\n            this._initSpatial();\r\n            this._soundV2.spatial.distanceModel = value;\r\n        }\r\n    }\r\n    /**\r\n     * @internal\r\n     * Back Compat\r\n     **/\r\n    public onended: () => any;\r\n    /**\r\n     * Gets or sets an object used to store user defined information for the sound.\r\n     */\r\n    public metadata: any = null;\r\n\r\n    /**\r\n     * Observable event when the current playing sound finishes.\r\n     */\r\n    public onEndedObservable = new Observable<Sound>();\r\n\r\n    /**\r\n     * Gets the current time for the sound.\r\n     */\r\n    public get currentTime(): number {\r\n        return this._soundV2 instanceof _WebAudioSoundSource ? this._soundV2.engine.currentTime : this._soundV2.currentTime;\r\n    }\r\n\r\n    /**\r\n     * Does this sound enables spatial sound.\r\n     * @see https://doc.babylonjs.com/legacy/audio#creating-a-spatial-3d-sound\r\n     */\r\n    public get spatialSound(): boolean {\r\n        return this._soundV2?._isSpatial ?? false;\r\n    }\r\n\r\n    /**\r\n     * Does this sound enables spatial sound.\r\n     * @see https://doc.babylonjs.com/legacy/audio#creating-a-spatial-3d-sound\r\n     */\r\n    public set spatialSound(newValue: boolean) {\r\n        if (this._soundV2) {\r\n            if (newValue) {\r\n                this._initSpatial();\r\n            } else {\r\n                this._soundV2._isSpatial = false;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _localDirection: Vector3 = new Vector3(1, 0, 0);\r\n    private _volume: number = 1;\r\n    private _isReadyToPlay: boolean = false;\r\n    private _isDirectional: boolean = false;\r\n    private _readyToPlayCallback: () => any;\r\n    private _scene: Scene;\r\n    private _connectedTransformNode: Nullable<TransformNode>;\r\n    private _customAttenuationFunction: (currentVolume: number, currentDistance: number, maxDistance: number, refDistance: number, rolloffFactor: number) => number;\r\n    private _registerFunc: Nullable<(connectedMesh: TransformNode) => void>;\r\n    private _isOutputConnected = false;\r\n    private _url: Nullable<string> = null;\r\n\r\n    private readonly _optionsV2: Partial<IStaticSoundOptions>;\r\n    private readonly _soundV2: _WebAudioSoundSource | _WebAudioStaticSound | _WebAudioStreamingSound;\r\n    private _onReadyObservable: Nullable<Observable<void>> = null;\r\n\r\n    private get _onReady(): Observable<void> {\r\n        if (!this._onReadyObservable) {\r\n            this._onReadyObservable = new Observable<void>();\r\n        }\r\n        return this._onReadyObservable;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public static _SceneComponentInitialization: (scene: Scene) => void = (_) => {\r\n        throw _WarnImport(\"AudioSceneComponent\");\r\n    };\r\n\r\n    /**\r\n     * Create a sound and attach it to a scene\r\n     * @param name Name of your sound\r\n     * @param urlOrArrayBuffer Url to the sound to load async or ArrayBuffer, it also works with MediaStreams and AudioBuffers\r\n     * @param scene defines the scene the sound belongs to\r\n     * @param readyToPlayCallback Provide a callback function if you'd like to load your code once the sound is ready to be played\r\n     * @param options Objects to provide with the current available options: autoplay, loop, volume, spatialSound, maxDistance, rolloffFactor, refDistance, distanceModel, panningModel, streaming\r\n     */\r\n    constructor(name: string, urlOrArrayBuffer: any, scene?: Nullable<Scene>, readyToPlayCallback: Nullable<() => void> = null, options?: ISoundOptions) {\r\n        scene = scene || EngineStore.LastCreatedScene;\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        this._scene = scene;\r\n        Sound._SceneComponentInitialization(scene);\r\n        this._readyToPlayCallback = readyToPlayCallback || (() => {});\r\n\r\n        // Default custom attenuation function is a linear attenuation\r\n        // eslint-disable-next-line @typescript-eslint/no-unused-vars\r\n        this._customAttenuationFunction = (currentVolume: number, currentDistance: number, maxDistance: number, refDistance: number, rolloffFactor: number) => {\r\n            if (currentDistance < maxDistance) {\r\n                return currentVolume * (1 - currentDistance / maxDistance);\r\n            } else {\r\n                return 0;\r\n            }\r\n        };\r\n\r\n        options = options || {};\r\n\r\n        const optionsV2: Partial<IStaticSoundOptions> = {\r\n            analyzerEnabled: false,\r\n            autoplay: false, // `false` for now, but will be set to given option later\r\n            duration: options.length || 0,\r\n            loop: options.loop || false,\r\n            loopEnd: 0,\r\n            loopStart: 0,\r\n            outBus: null,\r\n            outBusAutoDefault: false,\r\n            playbackRate: options.playbackRate || 1,\r\n            pitch: 0,\r\n            skipCodecCheck: options.skipCodecCheck || false,\r\n            spatialDistanceModel: options.distanceModel,\r\n            spatialEnabled: options.spatialSound,\r\n            spatialMaxDistance: options.maxDistance,\r\n            spatialMinDistance: options.refDistance,\r\n            spatialRolloffFactor: options.rolloffFactor,\r\n            stereoEnabled: false,\r\n            startOffset: options.offset || 0,\r\n            volume: options.volume ?? 1,\r\n        };\r\n        this._volume = options.volume ?? 1;\r\n\r\n        if (_HasSpatialAudioOptions(optionsV2)) {\r\n            optionsV2.spatialAutoUpdate = false;\r\n            optionsV2.spatialConeInnerAngle = _SpatialAudioDefaults.coneInnerAngle;\r\n            optionsV2.spatialConeOuterAngle = _SpatialAudioDefaults.coneOuterAngle;\r\n            optionsV2.spatialConeOuterVolume = _SpatialAudioDefaults.coneOuterVolume;\r\n            optionsV2.spatialMinUpdateTime = 0;\r\n            optionsV2.spatialOrientation = _SpatialAudioDefaults.orientation.clone();\r\n            optionsV2.spatialPanningModel = (this._scene.headphone ? \"HRTF\" : \"equalpower\") as \"equalpower\" | \"HRTF\";\r\n            optionsV2.spatialPosition = _SpatialAudioDefaults.position.clone();\r\n            optionsV2.spatialRotation = _SpatialAudioDefaults.rotation.clone();\r\n            optionsV2.spatialRotationQuaternion = _SpatialAudioDefaults.rotationQuaternion.clone();\r\n\r\n            if (optionsV2.spatialMaxDistance === undefined) {\r\n                optionsV2.spatialMaxDistance = 100;\r\n            }\r\n        }\r\n\r\n        this._optionsV2 = { ...optionsV2 };\r\n        this._optionsV2.autoplay = options.autoplay || false;\r\n\r\n        this.useCustomAttenuation = options.useCustomAttenuation ?? false;\r\n        if (this.useCustomAttenuation) {\r\n            optionsV2.spatialMaxDistance = Number.MAX_VALUE;\r\n            optionsV2.volume = 0;\r\n        }\r\n\r\n        let streaming = options?.streaming || false;\r\n\r\n        const audioEngine = AbstractEngine.audioEngine;\r\n        if (!audioEngine) {\r\n            return;\r\n        }\r\n\r\n        const audioEngineV2 = (AbstractEngine.audioEngine as AudioEngine)._v2;\r\n\r\n        const createSoundV2 = () => {\r\n            if (streaming) {\r\n                const streamingOptionsV2: Partial<IStreamingSoundOptions> = {\r\n                    preloadCount: 0,\r\n                    ...optionsV2,\r\n                };\r\n\r\n                const sound = new _WebAudioStreamingSound(name, audioEngineV2, streamingOptionsV2);\r\n\r\n                // eslint-disable-next-line github/no-then\r\n                void sound._initAsync(urlOrArrayBuffer, optionsV2).then(() => {\r\n                    // eslint-disable-next-line github/no-then\r\n                    void sound.preloadInstancesAsync(1).then(this._onReadyToPlay);\r\n                });\r\n\r\n                return sound;\r\n            } else {\r\n                const sound = new _WebAudioStaticSound(name, audioEngineV2, optionsV2);\r\n\r\n                // eslint-disable-next-line github/no-then\r\n                void sound._initAsync(urlOrArrayBuffer, optionsV2).then(this._onReadyToPlay);\r\n\r\n                return sound;\r\n            }\r\n        };\r\n\r\n        // If no parameter is passed then the setAudioBuffer should be called to prepare the sound.\r\n        if (!urlOrArrayBuffer) {\r\n            // Create the sound but don't call _initAsync on it, yet. Call it later when `setAudioBuffer` is called.\r\n            this._soundV2 = new _WebAudioStaticSound(name, audioEngineV2, optionsV2);\r\n        } else if (typeof urlOrArrayBuffer === \"string\") {\r\n            this._url = urlOrArrayBuffer;\r\n            this._soundV2 = createSoundV2();\r\n        } else if (urlOrArrayBuffer instanceof ArrayBuffer) {\r\n            streaming = false;\r\n            this._soundV2 = createSoundV2();\r\n        } else if (urlOrArrayBuffer instanceof HTMLMediaElement) {\r\n            streaming = true;\r\n            this._soundV2 = createSoundV2();\r\n        } else if (urlOrArrayBuffer instanceof MediaStream) {\r\n            const node = new MediaStreamAudioSourceNode(audioEngineV2._audioContext, { mediaStream: urlOrArrayBuffer });\r\n            this._soundV2 = new _WebAudioSoundSource(name, node, audioEngineV2, optionsV2);\r\n            // eslint-disable-next-line github/no-then\r\n            void this._soundV2._initAsync(optionsV2).then(this._onReadyToPlay);\r\n        } else if (urlOrArrayBuffer instanceof AudioBuffer) {\r\n            streaming = false;\r\n            this._soundV2 = createSoundV2();\r\n        } else if (Array.isArray(urlOrArrayBuffer)) {\r\n            this._soundV2 = createSoundV2();\r\n        }\r\n\r\n        if (!this._soundV2) {\r\n            Logger.Error(\"Parameter must be a URL to the sound, an Array of URLs (.mp3 & .ogg) or an ArrayBuffer of the sound.\");\r\n            return;\r\n        }\r\n\r\n        if (!(this._soundV2 instanceof _WebAudioSoundSource)) {\r\n            this._soundV2.onEndedObservable.add(this._onended);\r\n        }\r\n    }\r\n\r\n    private _onReadyToPlay = () => {\r\n        this._scene.mainSoundTrack.addSound(this);\r\n        this._isReadyToPlay = true;\r\n        this._readyToPlayCallback();\r\n\r\n        if (this._onReadyObservable) {\r\n            this._onReadyObservable.notifyObservers();\r\n        }\r\n\r\n        if (this._optionsV2.autoplay) {\r\n            this.play();\r\n        }\r\n    };\r\n\r\n    /**\r\n     * Release the sound and its associated resources\r\n     */\r\n    public dispose() {\r\n        if (this.isPlaying) {\r\n            this.stop();\r\n        }\r\n        this._isReadyToPlay = false;\r\n        if (this.soundTrackId === -1) {\r\n            this._scene.mainSoundTrack.removeSound(this);\r\n        } else if (this._scene.soundTracks) {\r\n            this._scene.soundTracks[this.soundTrackId].removeSound(this);\r\n        }\r\n\r\n        if (this._connectedTransformNode && this._registerFunc) {\r\n            this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\r\n            this._connectedTransformNode = null;\r\n        }\r\n\r\n        this._soundV2.dispose();\r\n    }\r\n\r\n    /**\r\n     * Gets if the sounds is ready to be played or not.\r\n     * @returns true if ready, otherwise false\r\n     */\r\n    public isReady(): boolean {\r\n        return this._isReadyToPlay;\r\n    }\r\n\r\n    /**\r\n     * Get the current class name.\r\n     * @returns current class name\r\n     */\r\n    public getClassName(): string {\r\n        return \"Sound\";\r\n    }\r\n\r\n    /**\r\n     * Sets the data of the sound from an audiobuffer\r\n     * @param audioBuffer The audioBuffer containing the data\r\n     */\r\n    public setAudioBuffer(audioBuffer: AudioBuffer): void {\r\n        if (this._isReadyToPlay) {\r\n            return;\r\n        }\r\n\r\n        if (this._soundV2 instanceof _WebAudioStaticSound) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises, github/no-then\r\n            this._soundV2._initAsync(audioBuffer, this._optionsV2).then(this._onReadyToPlay);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Updates the current sounds options such as maxdistance, loop...\r\n     * @param options A JSON object containing values named as the object properties\r\n     */\r\n    public updateOptions(options: ISoundOptions): void {\r\n        if (options) {\r\n            this.loop = options.loop ?? this.loop;\r\n            this.maxDistance = options.maxDistance ?? this.maxDistance;\r\n            this.useCustomAttenuation = options.useCustomAttenuation ?? this.useCustomAttenuation;\r\n            this.rolloffFactor = options.rolloffFactor ?? this.rolloffFactor;\r\n            this.refDistance = options.refDistance ?? this.refDistance;\r\n            this.distanceModel = options.distanceModel ?? this.distanceModel;\r\n            if (options.playbackRate !== undefined) {\r\n                this.setPlaybackRate(options.playbackRate);\r\n            }\r\n            if (options.spatialSound !== undefined) {\r\n                this.spatialSound = options.spatialSound;\r\n            }\r\n            if (options.volume !== undefined) {\r\n                this.setVolume(options.volume);\r\n            }\r\n            if (this._soundV2 instanceof _WebAudioStaticSound) {\r\n                let updated = false;\r\n                if (options.offset !== undefined) {\r\n                    this._optionsV2.startOffset = options.offset;\r\n                    updated = true;\r\n                }\r\n                if (options.length !== undefined) {\r\n                    this._soundV2.duration = options.length;\r\n                    updated = true;\r\n                }\r\n                if (updated && this.isPaused) {\r\n                    this.stop();\r\n                }\r\n            }\r\n\r\n            this._updateSpatialParameters();\r\n        }\r\n    }\r\n\r\n    private _updateSpatialParameters() {\r\n        if (!this.spatialSound) {\r\n            return;\r\n        }\r\n\r\n        const spatial = this._soundV2.spatial;\r\n\r\n        if (this.useCustomAttenuation) {\r\n            // Disable WebAudio attenuation.\r\n            spatial.distanceModel = \"linear\";\r\n            spatial.minDistance = 1;\r\n            spatial.maxDistance = Number.MAX_VALUE;\r\n            spatial.rolloffFactor = 1;\r\n            spatial.panningModel = \"equalpower\";\r\n        } else {\r\n            spatial.distanceModel = this.distanceModel;\r\n            spatial.minDistance = this.refDistance;\r\n            spatial.maxDistance = this.maxDistance;\r\n            spatial.rolloffFactor = this.rolloffFactor;\r\n            spatial.panningModel = this._optionsV2.spatialPanningModel || \"equalpower\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Switch the panning model to HRTF:\r\n     * Renders a stereo output of higher quality than equalpower — it uses a convolution with measured impulse responses from human subjects.\r\n     * @see https://doc.babylonjs.com/legacy/audio#creating-a-spatial-3d-sound\r\n     */\r\n    public switchPanningModelToHRTF() {\r\n        if (this.spatialSound) {\r\n            this._initSpatial();\r\n            this._soundV2.spatial.panningModel = \"HRTF\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Switch the panning model to Equal Power:\r\n     * Represents the equal-power panning algorithm, generally regarded as simple and efficient. equalpower is the default value.\r\n     * @see https://doc.babylonjs.com/legacy/audio#creating-a-spatial-3d-sound\r\n     */\r\n    public switchPanningModelToEqualPower() {\r\n        if (this.spatialSound) {\r\n            this._initSpatial();\r\n            this._soundV2.spatial.panningModel = \"equalpower\";\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Connect this sound to a sound track audio node like gain...\r\n     * @param soundTrackAudioNode the sound track audio node to connect to\r\n     */\r\n    public connectToSoundTrackAudioNode(soundTrackAudioNode: AudioNode): void {\r\n        const outputNode = this._soundV2._outNode;\r\n        if (outputNode) {\r\n            if (this._isOutputConnected) {\r\n                outputNode.disconnect();\r\n            }\r\n            outputNode.connect(soundTrackAudioNode);\r\n            this._isOutputConnected = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Transform this sound into a directional source\r\n     * @param coneInnerAngle Size of the inner cone in degree\r\n     * @param coneOuterAngle Size of the outer cone in degree\r\n     * @param coneOuterGain Volume of the sound outside the outer cone (between 0.0 and 1.0)\r\n     */\r\n    public setDirectionalCone(coneInnerAngle: number, coneOuterAngle: number, coneOuterGain: number): void {\r\n        if (coneOuterAngle < coneInnerAngle) {\r\n            Logger.Error(\"setDirectionalCone(): outer angle of the cone must be superior or equal to the inner angle.\");\r\n            return;\r\n        }\r\n\r\n        this._optionsV2.spatialConeInnerAngle = D2r(coneInnerAngle);\r\n        this._optionsV2.spatialConeOuterAngle = D2r(coneOuterAngle);\r\n        this._optionsV2.spatialConeOuterVolume = coneOuterGain;\r\n\r\n        this._initSpatial();\r\n        this._soundV2.spatial.coneInnerAngle = this._optionsV2.spatialConeInnerAngle;\r\n        this._soundV2.spatial.coneOuterAngle = this._optionsV2.spatialConeOuterAngle;\r\n        this._soundV2.spatial.coneOuterVolume = coneOuterGain;\r\n\r\n        this._isDirectional = true;\r\n\r\n        if (this.isPlaying && this.loop) {\r\n            this.stop();\r\n            this.play(0, this._optionsV2.startOffset, this._optionsV2.duration);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the inner angle for the directional cone.\r\n     */\r\n    public get directionalConeInnerAngle(): number {\r\n        return R2d(typeof this._optionsV2.spatialConeInnerAngle === \"number\" ? this._optionsV2.spatialConeInnerAngle : _SpatialAudioDefaults.coneInnerAngle);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the inner angle for the directional cone.\r\n     */\r\n    public set directionalConeInnerAngle(value: number) {\r\n        value = D2r(value);\r\n\r\n        if (value != this._optionsV2.spatialConeInnerAngle) {\r\n            if (this.directionalConeOuterAngle < value) {\r\n                Logger.Error(\"directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.\");\r\n                return;\r\n            }\r\n            this._optionsV2.spatialConeInnerAngle = value;\r\n            if (this.spatialSound) {\r\n                this._initSpatial();\r\n                this._soundV2.spatial.coneInnerAngle = value;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the outer angle for the directional cone.\r\n     */\r\n    public get directionalConeOuterAngle(): number {\r\n        return R2d(typeof this._optionsV2.spatialConeOuterAngle === \"number\" ? this._optionsV2.spatialConeOuterAngle : _SpatialAudioDefaults.coneOuterAngle);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the outer angle for the directional cone.\r\n     */\r\n    public set directionalConeOuterAngle(value: number) {\r\n        value = D2r(value);\r\n\r\n        if (value != this._optionsV2.spatialConeOuterAngle) {\r\n            if (value < this.directionalConeInnerAngle) {\r\n                Logger.Error(\"directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.\");\r\n                return;\r\n            }\r\n            this._optionsV2.spatialConeOuterAngle = value;\r\n            if (this.spatialSound) {\r\n                this._initSpatial();\r\n                this._soundV2.spatial.coneOuterAngle = value;\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the position of the emitter if spatial sound is enabled\r\n     * @param newPosition Defines the new position\r\n     */\r\n    public setPosition(newPosition: Vector3): void {\r\n        if (this._optionsV2.spatialPosition && newPosition.equals(this._optionsV2.spatialPosition)) {\r\n            return;\r\n        }\r\n        if (!this._optionsV2.spatialPosition) {\r\n            this._optionsV2.spatialPosition = Vector3.Zero();\r\n        }\r\n        this._optionsV2.spatialPosition.copyFrom(newPosition);\r\n        if (this.spatialSound && !isNaN(newPosition.x) && !isNaN(newPosition.y) && !isNaN(newPosition.z)) {\r\n            this._initSpatial();\r\n            this._soundV2.spatial.position = newPosition;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets the local direction of the emitter if spatial sound is enabled\r\n     * @param newLocalDirection Defines the new local direction\r\n     */\r\n    public setLocalDirectionToMesh(newLocalDirection: Vector3): void {\r\n        this._localDirection = newLocalDirection;\r\n\r\n        if (this._connectedTransformNode && this.isPlaying) {\r\n            this._updateDirection();\r\n        }\r\n    }\r\n\r\n    private _updateDirection() {\r\n        if (!this._connectedTransformNode || !this.spatialSound) {\r\n            return;\r\n        }\r\n\r\n        const mat = this._connectedTransformNode.getWorldMatrix();\r\n        const direction = Vector3.TransformNormal(this._localDirection, mat);\r\n        direction.normalize();\r\n\r\n        this._initSpatial();\r\n        this._soundV2.spatial.orientation = direction;\r\n    }\r\n\r\n    private _initSpatial() {\r\n        this._soundV2._isSpatial = true;\r\n\r\n        if (this._optionsV2.spatialDistanceModel === undefined) {\r\n            this._optionsV2.spatialDistanceModel = \"linear\";\r\n            this._soundV2.spatial.distanceModel = \"linear\";\r\n        }\r\n\r\n        if (this._optionsV2.spatialMaxDistance === undefined) {\r\n            this._optionsV2.spatialMaxDistance = 100;\r\n            this._soundV2.spatial.maxDistance = 100;\r\n        }\r\n    }\r\n\r\n    /** @internal */\r\n    public updateDistanceFromListener() {\r\n        if (this._soundV2._outNode && this._connectedTransformNode && this.useCustomAttenuation && this._scene.activeCamera) {\r\n            const distance = this._scene.audioListenerPositionProvider\r\n                ? this._connectedTransformNode.position.subtract(this._scene.audioListenerPositionProvider()).length()\r\n                : this._connectedTransformNode.getDistanceToCamera(this._scene.activeCamera);\r\n            this._soundV2.volume = this._customAttenuationFunction(this._volume, distance, this.maxDistance, this.refDistance, this.rolloffFactor);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Sets a new custom attenuation function for the sound.\r\n     * @param callback Defines the function used for the attenuation\r\n     * @see https://doc.babylonjs.com/legacy/audio#creating-your-own-custom-attenuation-function\r\n     */\r\n    public setAttenuationFunction(callback: (currentVolume: number, currentDistance: number, maxDistance: number, refDistance: number, rolloffFactor: number) => number): void {\r\n        this._customAttenuationFunction = callback;\r\n    }\r\n\r\n    /**\r\n     * Play the sound\r\n     * @param time (optional) Start the sound after X seconds. Start immediately (0) by default.\r\n     * @param offset (optional) Start the sound at a specific time in seconds\r\n     * @param length (optional) Sound duration (in seconds)\r\n     */\r\n    public play(time?: number, offset?: number, length?: number): void {\r\n        const audioEngine = AbstractEngine.audioEngine;\r\n        audioEngine?.unlock();\r\n\r\n        // WebAudio sound sources have no `play` function because they are always playing.\r\n        if (this._soundV2 instanceof _WebAudioSoundSource) {\r\n            return;\r\n        }\r\n\r\n        if (this._isReadyToPlay && this._scene.audioEnabled) {\r\n            // The sound can only resume from pause when the `time`, `offset` and `length` args are not set.\r\n            if (this._soundV2.state === SoundState.Paused && (time !== undefined || offset !== undefined || length !== undefined)) {\r\n                this._soundV2.stop();\r\n            }\r\n\r\n            try {\r\n                TmpPlayOptions.duration = length || 0;\r\n                TmpPlayOptions.startOffset = offset !== undefined ? offset || this._optionsV2.startOffset! : this._optionsV2.startOffset!;\r\n                TmpPlayOptions.waitTime = time || 0;\r\n\r\n                if (audioEngine?.unlocked) {\r\n                    this._soundV2.play(TmpPlayOptions);\r\n                } else {\r\n                    // Wait a bit for FF as context seems late to be ready.\r\n                    setTimeout(() => {\r\n                        (this._soundV2 as _WebAudioStaticSound | _WebAudioStreamingSound).play(TmpPlayOptions);\r\n                    }, 500);\r\n                }\r\n            } catch (ex) {\r\n                Logger.Error(\"Error while trying to play audio: \" + this.name + \", \" + ex.message);\r\n            }\r\n        }\r\n    }\r\n\r\n    private _onended = () => {\r\n        if (this.onended) {\r\n            this.onended();\r\n        }\r\n        this.onEndedObservable.notifyObservers(this);\r\n    };\r\n\r\n    /**\r\n     * Stop the sound\r\n     * @param time (optional) Stop the sound after X seconds. Stop immediately (0) by default.\r\n     */\r\n    public stop(time?: number): void {\r\n        if (!this._soundV2) {\r\n            return;\r\n        }\r\n\r\n        // WebAudio sound sources have no `stop` function because they are always playing.\r\n        if (this._soundV2 instanceof _WebAudioSoundSource) {\r\n            return;\r\n        }\r\n\r\n        TmpStopOptions.waitTime = time || 0;\r\n        this._soundV2.stop(TmpStopOptions);\r\n    }\r\n\r\n    /**\r\n     * Put the sound in pause\r\n     */\r\n    public pause(): void {\r\n        if (!this._soundV2) {\r\n            return;\r\n        }\r\n\r\n        // WebAudio sound sources have no `pause` function because they are always playing.\r\n        if (this._soundV2 instanceof _WebAudioSoundSource) {\r\n            return;\r\n        }\r\n\r\n        this._soundV2.pause();\r\n    }\r\n\r\n    /**\r\n     * Sets a dedicated volume for this sounds\r\n     * @param newVolume Define the new volume of the sound\r\n     * @param time Define time for gradual change to new volume\r\n     */\r\n    public setVolume(newVolume: number, time?: number): void {\r\n        if (!this.isReady()) {\r\n            this._onReady.addOnce(() => {\r\n                this.setVolume(newVolume, time);\r\n            });\r\n            return;\r\n        }\r\n\r\n        TmpRampOptions.duration = time || 0;\r\n        this._soundV2.setVolume(newVolume, TmpRampOptions);\r\n        this._volume = newVolume;\r\n    }\r\n\r\n    /**\r\n     * Set the sound play back rate\r\n     * @param newPlaybackRate Define the playback rate the sound should be played at\r\n     */\r\n    public setPlaybackRate(newPlaybackRate: number): void {\r\n        if (this._soundV2 instanceof _WebAudioStaticSound) {\r\n            this._soundV2.playbackRate = newPlaybackRate;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets the sound play back rate.\r\n     * @returns the  play back rate of the sound\r\n     */\r\n    public getPlaybackRate(): number {\r\n        if (this._soundV2 instanceof _WebAudioStaticSound) {\r\n            return this._soundV2.playbackRate;\r\n        }\r\n\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * Gets the volume of the sound.\r\n     * @returns the volume of the sound\r\n     */\r\n    public getVolume(): number {\r\n        return this._volume;\r\n    }\r\n\r\n    /**\r\n     * Attach the sound to a dedicated mesh\r\n     * @param transformNode The transform node to connect the sound with\r\n     * @see https://doc.babylonjs.com/legacy/audio#attaching-a-sound-to-a-mesh\r\n     */\r\n    public attachToMesh(transformNode: TransformNode): void {\r\n        if (this._connectedTransformNode && this._registerFunc) {\r\n            this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\r\n            this._registerFunc = null;\r\n        }\r\n        this._connectedTransformNode = transformNode;\r\n        if (!this.spatialSound) {\r\n            this.spatialSound = true;\r\n            if (this.isPlaying && this.loop) {\r\n                this.stop();\r\n                this.play(0, this._optionsV2.startOffset, this._optionsV2.duration);\r\n            }\r\n        }\r\n        this._onRegisterAfterWorldMatrixUpdate(this._connectedTransformNode);\r\n        this._registerFunc = (transformNode: TransformNode) => this._onRegisterAfterWorldMatrixUpdate(transformNode);\r\n        this._connectedTransformNode.registerAfterWorldMatrixUpdate(this._registerFunc);\r\n    }\r\n\r\n    /**\r\n     * Detach the sound from the previously attached mesh\r\n     * @see https://doc.babylonjs.com/legacy/audio#attaching-a-sound-to-a-mesh\r\n     */\r\n    public detachFromMesh() {\r\n        if (this._connectedTransformNode && this._registerFunc) {\r\n            this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);\r\n            this._registerFunc = null;\r\n            this._connectedTransformNode = null;\r\n        }\r\n    }\r\n\r\n    private _onRegisterAfterWorldMatrixUpdate(node: TransformNode): void {\r\n        if (!(<any>node).getBoundingInfo) {\r\n            this.setPosition(node.absolutePosition);\r\n        } else {\r\n            const mesh = node as AbstractMesh;\r\n            const boundingInfo = mesh.getBoundingInfo();\r\n            this.setPosition(boundingInfo.boundingSphere.centerWorld);\r\n        }\r\n        if (this._isDirectional && this.isPlaying) {\r\n            this._updateDirection();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clone the current sound in the scene.\r\n     * @returns the new sound clone\r\n     */\r\n    public clone(): Nullable<Sound> {\r\n        if (!(this._soundV2 instanceof _WebAudioStaticSound)) {\r\n            return null;\r\n        }\r\n\r\n        const currentOptions: ISoundOptions = {\r\n            autoplay: this.autoplay,\r\n            loop: this.loop,\r\n            volume: this._volume,\r\n            spatialSound: this.spatialSound,\r\n            maxDistance: this.maxDistance,\r\n            useCustomAttenuation: this.useCustomAttenuation,\r\n            rolloffFactor: this.rolloffFactor,\r\n            refDistance: this.refDistance,\r\n            distanceModel: this.distanceModel,\r\n        };\r\n        const clonedSound = new Sound(this.name + \"_cloned\", this._soundV2.buffer, this._scene, null, currentOptions);\r\n        (clonedSound._optionsV2 as any) = this._optionsV2;\r\n        if (this.useCustomAttenuation) {\r\n            clonedSound.setAttenuationFunction(this._customAttenuationFunction);\r\n        }\r\n        return clonedSound;\r\n    }\r\n\r\n    /**\r\n     * Gets the current underlying audio buffer containing the data\r\n     * @returns the audio buffer\r\n     */\r\n    public getAudioBuffer(): Nullable<AudioBuffer> {\r\n        if (this._soundV2 instanceof _WebAudioStaticSound) {\r\n            return this._soundV2.buffer._audioBuffer;\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the WebAudio AudioBufferSourceNode, lets you keep track of and stop instances of this Sound.\r\n     * @returns the source node\r\n     */\r\n    public getSoundSource(): Nullable<AudioBufferSourceNode> {\r\n        // return this._soundSource;\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * Gets the WebAudio GainNode, gives you precise control over the gain of instances of this Sound.\r\n     * @returns the gain node\r\n     */\r\n    public getSoundGain(): Nullable<GainNode> {\r\n        return this._soundV2._outNode as GainNode;\r\n    }\r\n\r\n    /**\r\n     * Serializes the Sound in a JSON representation\r\n     * @returns the JSON representation of the sound\r\n     */\r\n    public serialize(): any {\r\n        const serializationObject: any = {\r\n            name: this.name,\r\n            url: this._url,\r\n            autoplay: this.autoplay,\r\n            loop: this.loop,\r\n            volume: this._volume,\r\n            spatialSound: this.spatialSound,\r\n            maxDistance: this.maxDistance,\r\n            rolloffFactor: this.rolloffFactor,\r\n            refDistance: this.refDistance,\r\n            distanceModel: this.distanceModel,\r\n            playbackRate: this.getPlaybackRate(),\r\n            panningModel: this._soundV2.spatial.panningModel,\r\n            soundTrackId: this.soundTrackId,\r\n            metadata: this.metadata,\r\n        };\r\n\r\n        if (this.spatialSound) {\r\n            if (this._connectedTransformNode) {\r\n                serializationObject.connectedMeshId = this._connectedTransformNode.id;\r\n            }\r\n\r\n            serializationObject.position = this._soundV2.spatial.position.asArray();\r\n            serializationObject.refDistance = this.refDistance;\r\n            serializationObject.distanceModel = this.distanceModel;\r\n\r\n            serializationObject.isDirectional = this._isDirectional;\r\n            serializationObject.localDirectionToMesh = this._localDirection.asArray();\r\n            serializationObject.coneInnerAngle = this.directionalConeInnerAngle;\r\n            serializationObject.coneOuterAngle = this.directionalConeOuterAngle;\r\n            serializationObject.coneOuterGain = this._soundV2.spatial.coneOuterVolume;\r\n        }\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Parse a JSON representation of a sound to instantiate in a given scene\r\n     * @param parsedSound Define the JSON representation of the sound (usually coming from the serialize method)\r\n     * @param scene Define the scene the new parsed sound should be created in\r\n     * @param rootUrl Define the rooturl of the load in case we need to fetch relative dependencies\r\n     * @param sourceSound Define a sound place holder if do not need to instantiate a new one\r\n     * @returns the newly parsed sound\r\n     */\r\n    public static Parse(parsedSound: any, scene: Scene, rootUrl: string, sourceSound?: Sound): Sound {\r\n        const soundName = parsedSound.name;\r\n        let soundUrl;\r\n        if (parsedSound.url) {\r\n            soundUrl = rootUrl + parsedSound.url;\r\n        } else {\r\n            soundUrl = rootUrl + soundName;\r\n        }\r\n        const options = {\r\n            autoplay: parsedSound.autoplay,\r\n            loop: parsedSound.loop,\r\n            volume: parsedSound.volume,\r\n            spatialSound: parsedSound.spatialSound,\r\n            maxDistance: parsedSound.maxDistance,\r\n            rolloffFactor: parsedSound.rolloffFactor,\r\n            refDistance: parsedSound.refDistance,\r\n            distanceModel: parsedSound.distanceModel,\r\n            playbackRate: parsedSound.playbackRate,\r\n        };\r\n        let newSound: Sound;\r\n        if (!sourceSound) {\r\n            newSound = new Sound(\r\n                soundName,\r\n                soundUrl,\r\n                scene,\r\n                () => {\r\n                    scene.removePendingData(newSound);\r\n                },\r\n                options\r\n            );\r\n            scene.addPendingData(newSound);\r\n        } else {\r\n            const setBufferAndRun = () => {\r\n                _RetryWithInterval(\r\n                    () => sourceSound._isReadyToPlay,\r\n                    () => {\r\n                        const audioBuffer = sourceSound.getAudioBuffer();\r\n                        if (audioBuffer) {\r\n                            newSound.setAudioBuffer(audioBuffer);\r\n                        }\r\n                        newSound._isReadyToPlay = true;\r\n                        if (newSound.autoplay) {\r\n                            newSound.play(0, sourceSound._optionsV2.startOffset, sourceSound._optionsV2.duration);\r\n                        }\r\n                    },\r\n                    undefined,\r\n                    300\r\n                );\r\n            };\r\n            newSound = new Sound(soundName, new ArrayBuffer(0), scene, null, options);\r\n            setBufferAndRun();\r\n        }\r\n        if (parsedSound.position) {\r\n            const soundPosition = Vector3.FromArray(parsedSound.position);\r\n            newSound.setPosition(soundPosition);\r\n        }\r\n        if (parsedSound.isDirectional) {\r\n            newSound.setDirectionalCone(parsedSound.coneInnerAngle || 360, parsedSound.coneOuterAngle || 360, parsedSound.coneOuterGain || 0);\r\n            if (parsedSound.localDirectionToMesh) {\r\n                const localDirectionToMesh = Vector3.FromArray(parsedSound.localDirectionToMesh);\r\n                newSound.setLocalDirectionToMesh(localDirectionToMesh);\r\n            }\r\n        }\r\n        if (parsedSound.connectedMeshId) {\r\n            const connectedMesh = scene.getMeshById(parsedSound.connectedMeshId);\r\n            if (connectedMesh) {\r\n                newSound.attachToMesh(connectedMesh);\r\n            }\r\n        }\r\n        if (parsedSound.metadata) {\r\n            newSound.metadata = parsedSound.metadata;\r\n        }\r\n        return newSound;\r\n    }\r\n}\r\n\r\n// Register Class Name\r\nRegisterClass(\"BABYLON.Sound\", Sound);\r\n", "import type { Sound } from \"./sound\";\r\nimport type { Analyser } from \"./analyser\";\r\nimport type { Nullable } from \"../types\";\r\nimport type { Scene } from \"../scene\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { AbstractEngine } from \"core/Engines/abstractEngine\";\r\n\r\n/**\r\n * Options allowed during the creation of a sound track.\r\n */\r\nexport interface ISoundTrackOptions {\r\n    /**\r\n     * The volume the sound track should take during creation\r\n     */\r\n    volume?: number;\r\n    /**\r\n     * Define if the sound track is the main sound track of the scene\r\n     */\r\n    mainTrack?: boolean;\r\n}\r\n\r\n/**\r\n * It could be useful to isolate your music & sounds on several tracks to better manage volume on a grouped instance of sounds.\r\n * It will be also used in a future release to apply effects on a specific track.\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#using-sound-tracks\r\n */\r\nexport class SoundTrack {\r\n    /**\r\n     * The unique identifier of the sound track in the scene.\r\n     */\r\n    public id: number = -1;\r\n    /**\r\n     * The list of sounds included in the sound track.\r\n     */\r\n    public soundCollection: Array<Sound>;\r\n\r\n    private _outputAudioNode: Nullable<GainNode>;\r\n    private _scene: Scene;\r\n    private _connectedAnalyser: Analyser;\r\n    private _options: ISoundTrackOptions;\r\n    private _isInitialized = false;\r\n\r\n    /**\r\n     * Creates a new sound track.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#using-sound-tracks\r\n     * @param scene Define the scene the sound track belongs to\r\n     * @param options\r\n     */\r\n    constructor(scene?: Nullable<Scene>, options: ISoundTrackOptions = {}) {\r\n        scene = scene || EngineStore.LastCreatedScene;\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        this._scene = scene;\r\n        this.soundCollection = [];\r\n        this._options = options;\r\n\r\n        if (!this._options.mainTrack && this._scene.soundTracks) {\r\n            this._scene.soundTracks.push(this);\r\n            this.id = this._scene.soundTracks.length - 1;\r\n        }\r\n    }\r\n\r\n    private _initializeSoundTrackAudioGraph() {\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio && AbstractEngine.audioEngine.audioContext) {\r\n            this._outputAudioNode = AbstractEngine.audioEngine.audioContext.createGain();\r\n            this._outputAudioNode.connect(AbstractEngine.audioEngine.masterGain);\r\n\r\n            if (this._options) {\r\n                if (this._options.volume) {\r\n                    this._outputAudioNode.gain.value = this._options.volume;\r\n                }\r\n            }\r\n\r\n            this._isInitialized = true;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Release the sound track and its associated resources\r\n     */\r\n    public dispose(): void {\r\n        if (AbstractEngine.audioEngine && AbstractEngine.audioEngine.canUseWebAudio) {\r\n            if (this._connectedAnalyser) {\r\n                this._connectedAnalyser.stopDebugCanvas();\r\n            }\r\n            while (this.soundCollection.length) {\r\n                this.soundCollection[0].dispose();\r\n            }\r\n            if (this._outputAudioNode) {\r\n                this._outputAudioNode.disconnect();\r\n            }\r\n            this._outputAudioNode = null;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds a sound to this sound track\r\n     * @param sound define the sound to add\r\n     * @ignoreNaming\r\n     */\r\n    public addSound(sound: Sound): void {\r\n        if (!this._isInitialized) {\r\n            this._initializeSoundTrackAudioGraph();\r\n        }\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio && this._outputAudioNode) {\r\n            sound.connectToSoundTrackAudioNode(this._outputAudioNode);\r\n        }\r\n        if (sound.soundTrackId !== undefined) {\r\n            if (sound.soundTrackId === -1) {\r\n                this._scene.mainSoundTrack.removeSound(sound);\r\n            } else if (this._scene.soundTracks) {\r\n                this._scene.soundTracks[sound.soundTrackId].removeSound(sound);\r\n            }\r\n        }\r\n\r\n        this.soundCollection.push(sound);\r\n        sound.soundTrackId = this.id;\r\n    }\r\n\r\n    /**\r\n     * Removes a sound to this sound track\r\n     * @param sound define the sound to remove\r\n     * @ignoreNaming\r\n     */\r\n    public removeSound(sound: Sound): void {\r\n        const index = this.soundCollection.indexOf(sound);\r\n        if (index !== -1) {\r\n            this.soundCollection.splice(index, 1);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Set a global volume for the full sound track.\r\n     * @param newVolume Define the new volume of the sound track\r\n     */\r\n    public setVolume(newVolume: number): void {\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio && this._outputAudioNode) {\r\n            this._outputAudioNode.gain.value = newVolume;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Switch the panning model to HRTF:\r\n     * Renders a stereo output of higher quality than equalpower — it uses a convolution with measured impulse responses from human subjects.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\r\n     */\r\n    public switchPanningModelToHRTF(): void {\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio) {\r\n            for (let i = 0; i < this.soundCollection.length; i++) {\r\n                this.soundCollection[i].switchPanningModelToHRTF();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Switch the panning model to Equal Power:\r\n     * Represents the equal-power panning algorithm, generally regarded as simple and efficient. equalpower is the default value.\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#creating-a-spatial-3d-sound\r\n     */\r\n    public switchPanningModelToEqualPower(): void {\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio) {\r\n            for (let i = 0; i < this.soundCollection.length; i++) {\r\n                this.soundCollection[i].switchPanningModelToEqualPower();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Connect the sound track to an audio analyser allowing some amazing\r\n     * synchronization between the sounds/music and your visualization (VuMeter for instance).\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/audio/playingSoundsMusic#using-the-analyser\r\n     * @param analyser The analyser to connect to the engine\r\n     */\r\n    public connectToAnalyser(analyser: Analyser): void {\r\n        if (this._connectedAnalyser) {\r\n            this._connectedAnalyser.stopDebugCanvas();\r\n        }\r\n        this._connectedAnalyser = analyser;\r\n        if (AbstractEngine.audioEngine?.canUseWebAudio && this._outputAudioNode) {\r\n            this._outputAudioNode.disconnect();\r\n            this._connectedAnalyser.connectAudioNodes(this._outputAudioNode, AbstractEngine.audioEngine.masterGain);\r\n        }\r\n    }\r\n}\r\n", "import type { AssetContainer } from \"core/assetContainer\";\r\nimport type { Scene } from \"core/scene\";\r\nimport type { Nullable } from \"core/types\";\r\n\r\n/**\r\n * Defines how the parser contract is defined.\r\n * These parsers are used to parse a list of specific assets (like particle systems, etc..)\r\n */\r\nexport type BabylonFileParser = (parsedData: any, scene: Scene, container: AssetContainer, rootUrl: string) => void;\r\n\r\n/**\r\n * Defines how the individual parser contract is defined.\r\n * These parser can parse an individual asset\r\n */\r\nexport type IndividualBabylonFileParser = (parsedData: any, scene: Scene, rootUrl: string) => any;\r\n\r\n/**\r\n * Stores the list of available parsers in the application.\r\n */\r\nconst BabylonFileParsers: { [key: string]: BabylonFileParser } = {};\r\n\r\n/**\r\n * Stores the list of available individual parsers in the application.\r\n */\r\nconst IndividualBabylonFileParsers: { [key: string]: IndividualBabylonFileParser } = {};\r\n\r\n/**\r\n * Adds a parser in the list of available ones\r\n * @param name Defines the name of the parser\r\n * @param parser Defines the parser to add\r\n */\r\nexport function AddParser(name: string, parser: BabylonFileParser): void {\r\n    BabylonFileParsers[name] = parser;\r\n}\r\n\r\n/**\r\n * Gets a general parser from the list of available ones\r\n * @param name Defines the name of the parser\r\n * @returns the requested parser or null\r\n */\r\nexport function GetParser(name: string): Nullable<BabylonFileParser> {\r\n    if (BabylonFileParsers[name]) {\r\n        return BabylonFileParsers[name];\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Adds n individual parser in the list of available ones\r\n * @param name Defines the name of the parser\r\n * @param parser Defines the parser to add\r\n */\r\nexport function AddIndividualParser(name: string, parser: IndividualBabylonFileParser): void {\r\n    IndividualBabylonFileParsers[name] = parser;\r\n}\r\n\r\n/**\r\n * Gets an individual parser from the list of available ones\r\n * @param name Defines the name of the parser\r\n * @returns the requested parser or null\r\n */\r\nexport function GetIndividualParser(name: string): Nullable<IndividualBabylonFileParser> {\r\n    if (IndividualBabylonFileParsers[name]) {\r\n        return IndividualBabylonFileParsers[name];\r\n    }\r\n\r\n    return null;\r\n}\r\n\r\n/**\r\n * Parser json data and populate both a scene and its associated container object\r\n * @param jsonData Defines the data to parse\r\n * @param scene Defines the scene to parse the data for\r\n * @param container Defines the container attached to the parsing sequence\r\n * @param rootUrl Defines the root url of the data\r\n */\r\nexport function Parse(jsonData: any, scene: Scene, container: AssetContainer, rootUrl: string): void {\r\n    for (const parserName in BabylonFileParsers) {\r\n        if (Object.prototype.hasOwnProperty.call(BabylonFileParsers, parserName)) {\r\n            BabylonFileParsers[parserName](jsonData, scene, container, rootUrl);\r\n        }\r\n    }\r\n}\r\n", "import { Sound } from \"./sound\";\r\nimport { SoundTrack } from \"./soundTrack\";\r\nimport type { Nullable } from \"../types\";\r\nimport { Matrix, Vector3 } from \"../Maths/math.vector\";\r\nimport type { ISceneSerializableComponent } from \"../sceneComponent\";\r\nimport { SceneComponentConstants } from \"../sceneComponent\";\r\nimport { Scene } from \"../scene\";\r\nimport type { AssetContainer } from \"../assetContainer\";\r\n\r\nimport \"./audioEngine\";\r\nimport { PrecisionDate } from \"../Misc/precisionDate\";\r\nimport { EngineStore } from \"../Engines/engineStore\";\r\nimport { AbstractEngine } from \"core/Engines/abstractEngine\";\r\nimport { AddParser } from \"core/Loading/Plugins/babylonFileParser.function\";\r\nimport type { IAssetContainer } from \"core/IAssetContainer\";\r\n\r\n// Adds the parser to the scene parsers.\r\nAddParser(SceneComponentConstants.NAME_AUDIO, (parsedData: any, scene: Scene, container: AssetContainer, rootUrl: string) => {\r\n    // TODO: add sound\r\n    let loadedSounds: Sound[] = [];\r\n    let loadedSound: Sound;\r\n    container.sounds = container.sounds || [];\r\n    if (parsedData.sounds !== undefined && parsedData.sounds !== null) {\r\n        for (let index = 0, cache = parsedData.sounds.length; index < cache; index++) {\r\n            const parsedSound = parsedData.sounds[index];\r\n            if (AbstractEngine.audioEngine?.canUseWebAudio) {\r\n                if (!parsedSound.url) {\r\n                    parsedSound.url = parsedSound.name;\r\n                }\r\n                if (!loadedSounds[parsedSound.url]) {\r\n                    loadedSound = Sound.Parse(parsedSound, scene, rootUrl);\r\n                    loadedSounds[parsedSound.url] = loadedSound;\r\n                    container.sounds.push(loadedSound);\r\n                } else {\r\n                    container.sounds.push(Sound.Parse(parsedSound, scene, rootUrl, loadedSounds[parsedSound.url]));\r\n                }\r\n            } else {\r\n                container.sounds.push(new Sound(parsedSound.name, null, scene));\r\n            }\r\n        }\r\n    }\r\n\r\n    loadedSounds = [];\r\n});\r\n\r\ndeclare module \"../scene\" {\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    export interface Scene {\r\n        /**\r\n         * @internal\r\n         * Backing field\r\n         */\r\n        _mainSoundTrack: SoundTrack;\r\n        /**\r\n         * The main sound track played by the scene.\r\n         * It contains your primary collection of sounds.\r\n         * @deprecated please use AudioEngineV2 instead\r\n         */\r\n        mainSoundTrack: SoundTrack;\r\n        /**\r\n         * The list of sound tracks added to the scene\r\n         * @deprecated please use AudioEngineV2 instead\r\n         */\r\n        soundTracks: Nullable<Array<SoundTrack>>;\r\n\r\n        /**\r\n         * Gets a sound using a given name\r\n         * @param name defines the name to search for\r\n         * @returns the found sound or null if not found at all.\r\n         * @deprecated please use AudioEngineV2 instead\r\n         */\r\n        getSoundByName(name: string): Nullable<Sound>;\r\n\r\n        /**\r\n         * Gets or sets if audio support is enabled\r\n         * @deprecated please use AudioEngineV2 instead\r\n         */\r\n        audioEnabled: boolean;\r\n\r\n        /**\r\n         * Gets or sets if audio will be output to headphones\r\n         * @deprecated please use AudioEngineV2 instead\r\n         */\r\n        headphone: boolean;\r\n\r\n        /**\r\n         * Gets or sets custom audio listener position provider\r\n         * @deprecated please use AudioEngineV2 instead\r\n         */\r\n        audioListenerPositionProvider: Nullable<() => Vector3>;\r\n\r\n        /**\r\n         * Gets or sets custom audio listener rotation provider\r\n         * @deprecated please use AudioEngineV2 instead\r\n         */\r\n        audioListenerRotationProvider: Nullable<() => Vector3>;\r\n\r\n        /**\r\n         * Gets or sets a refresh rate when using 3D audio positioning\r\n         * @deprecated please use AudioEngineV2 instead\r\n         */\r\n        audioPositioningRefreshRate: number;\r\n    }\r\n}\r\n\r\nObject.defineProperty(Scene.prototype, \"mainSoundTrack\", {\r\n    get: function (this: Scene) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        if (!this._mainSoundTrack) {\r\n            this._mainSoundTrack = new SoundTrack(this, { mainTrack: true });\r\n        }\r\n\r\n        return this._mainSoundTrack;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nScene.prototype.getSoundByName = function (name: string): Nullable<Sound> {\r\n    let index: number;\r\n    for (index = 0; index < this.mainSoundTrack.soundCollection.length; index++) {\r\n        if (this.mainSoundTrack.soundCollection[index].name === name) {\r\n            return this.mainSoundTrack.soundCollection[index];\r\n        }\r\n    }\r\n\r\n    if (this.soundTracks) {\r\n        for (let sdIndex = 0; sdIndex < this.soundTracks.length; sdIndex++) {\r\n            for (index = 0; index < this.soundTracks[sdIndex].soundCollection.length; index++) {\r\n                if (this.soundTracks[sdIndex].soundCollection[index].name === name) {\r\n                    return this.soundTracks[sdIndex].soundCollection[index];\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    return null;\r\n};\r\n\r\nObject.defineProperty(Scene.prototype, \"audioEnabled\", {\r\n    get: function (this: Scene) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        return compo.audioEnabled;\r\n    },\r\n    set: function (this: Scene, value: boolean) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        if (value) {\r\n            compo.enableAudio();\r\n        } else {\r\n            compo.disableAudio();\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nObject.defineProperty(Scene.prototype, \"headphone\", {\r\n    get: function (this: Scene) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        return compo.headphone;\r\n    },\r\n    set: function (this: Scene, value: boolean) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        if (value) {\r\n            compo.switchAudioModeForHeadphones();\r\n        } else {\r\n            compo.switchAudioModeForNormalSpeakers();\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nObject.defineProperty(Scene.prototype, \"audioListenerPositionProvider\", {\r\n    get: function (this: Scene) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        return compo.audioListenerPositionProvider;\r\n    },\r\n    set: function (this: Scene, value: () => Vector3) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        if (value && typeof value !== \"function\") {\r\n            throw new Error(\"The value passed to [Scene.audioListenerPositionProvider] must be a function that returns a Vector3\");\r\n        } else {\r\n            compo.audioListenerPositionProvider = value;\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nObject.defineProperty(Scene.prototype, \"audioListenerRotationProvider\", {\r\n    get: function (this: Scene) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        return compo.audioListenerRotationProvider;\r\n    },\r\n    set: function (this: Scene, value: () => Vector3) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        if (value && typeof value !== \"function\") {\r\n            throw new Error(\"The value passed to [Scene.audioListenerRotationProvider] must be a function that returns a Vector3\");\r\n        } else {\r\n            compo.audioListenerRotationProvider = value;\r\n        }\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\nObject.defineProperty(Scene.prototype, \"audioPositioningRefreshRate\", {\r\n    get: function (this: Scene) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        return compo.audioPositioningRefreshRate;\r\n    },\r\n    set: function (this: Scene, value: number) {\r\n        let compo = this._getComponent(SceneComponentConstants.NAME_AUDIO) as AudioSceneComponent;\r\n        if (!compo) {\r\n            compo = new AudioSceneComponent(this);\r\n            this._addComponent(compo);\r\n        }\r\n\r\n        compo.audioPositioningRefreshRate = value;\r\n    },\r\n    enumerable: true,\r\n    configurable: true,\r\n});\r\n\r\n/**\r\n * Defines the sound scene component responsible to manage any sounds\r\n * in a given scene.\r\n * @deprecated please use AudioEngineV2 instead\r\n */\r\nexport class AudioSceneComponent implements ISceneSerializableComponent {\r\n    private static _CameraDirection = new Vector3(0, 0, -1);\r\n\r\n    /**\r\n     * The component name helpful to identify the component in the list of scene components.\r\n     */\r\n    public readonly name = SceneComponentConstants.NAME_AUDIO;\r\n\r\n    /**\r\n     * The scene the component belongs to.\r\n     */\r\n    public scene: Scene;\r\n\r\n    private _audioEnabled = true;\r\n    /**\r\n     * Gets whether audio is enabled or not.\r\n     * Please use related enable/disable method to switch state.\r\n     */\r\n    public get audioEnabled(): boolean {\r\n        return this._audioEnabled;\r\n    }\r\n\r\n    private _headphone = false;\r\n    /**\r\n     * Gets whether audio is outputting to headphone or not.\r\n     * Please use the according Switch methods to change output.\r\n     */\r\n    public get headphone(): boolean {\r\n        return this._headphone;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a refresh rate when using 3D audio positioning\r\n     */\r\n    public audioPositioningRefreshRate = 500;\r\n\r\n    /**\r\n     * Gets or Sets a custom listener position for all sounds in the scene\r\n     * By default, this is the position of the first active camera\r\n     */\r\n    public audioListenerPositionProvider: Nullable<() => Vector3> = null;\r\n\r\n    /**\r\n     * Gets or Sets a custom listener rotation for all sounds in the scene\r\n     * By default, this is the rotation of the first active camera\r\n     */\r\n    public audioListenerRotationProvider: Nullable<() => Vector3> = null;\r\n\r\n    /**\r\n     * Creates a new instance of the component for the given scene\r\n     * @param scene Defines the scene to register the component in\r\n     */\r\n    constructor(scene?: Nullable<Scene>) {\r\n        scene = scene || EngineStore.LastCreatedScene;\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        this.scene = scene;\r\n\r\n        scene.soundTracks = [] as SoundTrack[];\r\n        scene.sounds = [] as Sound[];\r\n    }\r\n\r\n    /**\r\n     * Registers the component in a given scene\r\n     */\r\n    public register(): void {\r\n        this.scene._afterRenderStage.registerStep(SceneComponentConstants.STEP_AFTERRENDER_AUDIO, this, this._afterRender);\r\n    }\r\n\r\n    /**\r\n     * Rebuilds the elements related to this component in case of\r\n     * context lost for instance.\r\n     */\r\n    public rebuild(): void {\r\n        // Nothing to do here. (Not rendering related)\r\n    }\r\n\r\n    /**\r\n     * Serializes the component data to the specified json object\r\n     * @param serializationObject The object to serialize to\r\n     */\r\n    public serialize(serializationObject: any): void {\r\n        serializationObject.sounds = [];\r\n\r\n        if (this.scene.soundTracks) {\r\n            for (let index = 0; index < this.scene.soundTracks.length; index++) {\r\n                const soundtrack = this.scene.soundTracks[index];\r\n\r\n                for (let soundId = 0; soundId < soundtrack.soundCollection.length; soundId++) {\r\n                    serializationObject.sounds.push(soundtrack.soundCollection[soundId].serialize());\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Adds all the elements from the container to the scene\r\n     * @param container the container holding the elements\r\n     */\r\n    public addFromContainer(container: IAssetContainer): void {\r\n        if (!container.sounds) {\r\n            return;\r\n        }\r\n        for (const sound of container.sounds) {\r\n            sound.play();\r\n            sound.autoplay = true;\r\n            this.scene.mainSoundTrack.addSound(sound);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Removes all the elements in the container from the scene\r\n     * @param container contains the elements to remove\r\n     * @param dispose if the removed element should be disposed (default: false)\r\n     */\r\n    public removeFromContainer(container: IAssetContainer, dispose = false): void {\r\n        if (!container.sounds) {\r\n            return;\r\n        }\r\n        for (const sound of container.sounds) {\r\n            sound.stop();\r\n            sound.autoplay = false;\r\n            this.scene.mainSoundTrack.removeSound(sound);\r\n            if (dispose) {\r\n                sound.dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disposes the component and the associated resources.\r\n     */\r\n    public dispose(): void {\r\n        const scene = this.scene;\r\n        if (scene._mainSoundTrack) {\r\n            scene.mainSoundTrack.dispose();\r\n        }\r\n\r\n        if (scene.soundTracks) {\r\n            for (let scIndex = 0; scIndex < scene.soundTracks.length; scIndex++) {\r\n                scene.soundTracks[scIndex].dispose();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Disables audio in the associated scene.\r\n     */\r\n    public disableAudio() {\r\n        const scene = this.scene;\r\n        this._audioEnabled = false;\r\n\r\n        if (AbstractEngine.audioEngine && AbstractEngine.audioEngine.audioContext) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n            AbstractEngine.audioEngine.audioContext.suspend();\r\n        }\r\n\r\n        let i: number;\r\n        for (i = 0; i < scene.mainSoundTrack.soundCollection.length; i++) {\r\n            scene.mainSoundTrack.soundCollection[i].pause();\r\n        }\r\n        if (scene.soundTracks) {\r\n            for (i = 0; i < scene.soundTracks.length; i++) {\r\n                for (let j = 0; j < scene.soundTracks[i].soundCollection.length; j++) {\r\n                    scene.soundTracks[i].soundCollection[j].pause();\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Enables audio in the associated scene.\r\n     */\r\n    public enableAudio() {\r\n        const scene = this.scene;\r\n        this._audioEnabled = true;\r\n\r\n        if (AbstractEngine.audioEngine && AbstractEngine.audioEngine.audioContext) {\r\n            // eslint-disable-next-line @typescript-eslint/no-floating-promises\r\n            AbstractEngine.audioEngine.audioContext.resume();\r\n        }\r\n\r\n        let i: number;\r\n        for (i = 0; i < scene.mainSoundTrack.soundCollection.length; i++) {\r\n            if (scene.mainSoundTrack.soundCollection[i].isPaused) {\r\n                scene.mainSoundTrack.soundCollection[i].play();\r\n            }\r\n        }\r\n        if (scene.soundTracks) {\r\n            for (i = 0; i < scene.soundTracks.length; i++) {\r\n                for (let j = 0; j < scene.soundTracks[i].soundCollection.length; j++) {\r\n                    if (scene.soundTracks[i].soundCollection[j].isPaused) {\r\n                        scene.soundTracks[i].soundCollection[j].play();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Switch audio to headphone output.\r\n     */\r\n    public switchAudioModeForHeadphones() {\r\n        const scene = this.scene;\r\n        this._headphone = true;\r\n\r\n        scene.mainSoundTrack.switchPanningModelToHRTF();\r\n        if (scene.soundTracks) {\r\n            for (let i = 0; i < scene.soundTracks.length; i++) {\r\n                scene.soundTracks[i].switchPanningModelToHRTF();\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Switch audio to normal speakers.\r\n     */\r\n    public switchAudioModeForNormalSpeakers() {\r\n        const scene = this.scene;\r\n        this._headphone = false;\r\n\r\n        scene.mainSoundTrack.switchPanningModelToEqualPower();\r\n\r\n        if (scene.soundTracks) {\r\n            for (let i = 0; i < scene.soundTracks.length; i++) {\r\n                scene.soundTracks[i].switchPanningModelToEqualPower();\r\n            }\r\n        }\r\n    }\r\n\r\n    private _cachedCameraDirection = new Vector3();\r\n    private _cachedCameraPosition = new Vector3();\r\n    private _lastCheck = 0;\r\n    private _invertMatrixTemp = new Matrix();\r\n    private _cameraDirectionTemp = new Vector3();\r\n\r\n    private _afterRender() {\r\n        const now = PrecisionDate.Now;\r\n        if (this._lastCheck && now - this._lastCheck < this.audioPositioningRefreshRate) {\r\n            return;\r\n        }\r\n\r\n        this._lastCheck = now;\r\n\r\n        const scene = this.scene;\r\n        if (!this._audioEnabled || !scene._mainSoundTrack || !scene.soundTracks || (scene._mainSoundTrack.soundCollection.length === 0 && scene.soundTracks.length === 1)) {\r\n            return;\r\n        }\r\n\r\n        const audioEngine = AbstractEngine.audioEngine;\r\n\r\n        if (!audioEngine) {\r\n            return;\r\n        }\r\n\r\n        if (audioEngine.audioContext) {\r\n            let listeningCamera = scene.activeCamera;\r\n            if (scene.activeCameras && scene.activeCameras.length > 0) {\r\n                listeningCamera = scene.activeCameras[0];\r\n            }\r\n\r\n            // A custom listener position provider was set\r\n            // Use the users provided position instead of camera's\r\n            if (this.audioListenerPositionProvider) {\r\n                const position: Vector3 = this.audioListenerPositionProvider();\r\n                // Set the listener position\r\n                audioEngine.audioContext.listener.setPosition(position.x || 0, position.y || 0, position.z || 0);\r\n                // Check if there is a listening camera\r\n            } else if (listeningCamera) {\r\n                // Set the listener position to the listening camera global position\r\n                if (!this._cachedCameraPosition.equals(listeningCamera.globalPosition)) {\r\n                    this._cachedCameraPosition.copyFrom(listeningCamera.globalPosition);\r\n                    audioEngine.audioContext.listener.setPosition(listeningCamera.globalPosition.x, listeningCamera.globalPosition.y, listeningCamera.globalPosition.z);\r\n                }\r\n            }\r\n            // Otherwise set the listener position to 0, 0 ,0\r\n            else {\r\n                // Set the listener position\r\n                audioEngine.audioContext.listener.setPosition(0, 0, 0);\r\n            }\r\n\r\n            // A custom listener rotation provider was set\r\n            // Use the users provided rotation instead of camera's\r\n            if (this.audioListenerRotationProvider) {\r\n                const rotation: Vector3 = this.audioListenerRotationProvider();\r\n                audioEngine.audioContext.listener.setOrientation(rotation.x || 0, rotation.y || 0, rotation.z || 0, 0, 1, 0);\r\n                // Check if there is a listening camera\r\n            } else if (listeningCamera) {\r\n                // for VR cameras\r\n                if (listeningCamera.rigCameras && listeningCamera.rigCameras.length > 0) {\r\n                    listeningCamera = listeningCamera.rigCameras[0];\r\n                }\r\n\r\n                listeningCamera.getViewMatrix().invertToRef(this._invertMatrixTemp);\r\n                Vector3.TransformNormalToRef(AudioSceneComponent._CameraDirection, this._invertMatrixTemp, this._cameraDirectionTemp);\r\n                this._cameraDirectionTemp.normalize();\r\n                // To avoid some errors on GearVR\r\n                if (!isNaN(this._cameraDirectionTemp.x) && !isNaN(this._cameraDirectionTemp.y) && !isNaN(this._cameraDirectionTemp.z)) {\r\n                    if (!this._cachedCameraDirection.equals(this._cameraDirectionTemp)) {\r\n                        this._cachedCameraDirection.copyFrom(this._cameraDirectionTemp);\r\n                        audioEngine.audioContext.listener.setOrientation(this._cameraDirectionTemp.x, this._cameraDirectionTemp.y, this._cameraDirectionTemp.z, 0, 1, 0);\r\n                    }\r\n                }\r\n            }\r\n            // Otherwise set the listener rotation to 0, 0 ,0\r\n            else {\r\n                // Set the listener position\r\n                audioEngine.audioContext.listener.setOrientation(0, 0, 0, 0, 1, 0);\r\n            }\r\n\r\n            let i: number;\r\n            for (i = 0; i < scene.mainSoundTrack.soundCollection.length; i++) {\r\n                const sound = scene.mainSoundTrack.soundCollection[i];\r\n                if (sound.useCustomAttenuation) {\r\n                    sound.updateDistanceFromListener();\r\n                }\r\n            }\r\n            if (scene.soundTracks) {\r\n                for (i = 0; i < scene.soundTracks.length; i++) {\r\n                    for (let j = 0; j < scene.soundTracks[i].soundCollection.length; j++) {\r\n                        const sound = scene.soundTracks[i].soundCollection[j];\r\n                        if (sound.useCustomAttenuation) {\r\n                            sound.updateDistanceFromListener();\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nSound._SceneComponentInitialization = (scene: Scene) => {\r\n    let compo = scene._getComponent(SceneComponentConstants.NAME_AUDIO);\r\n    if (!compo) {\r\n        compo = new AudioSceneComponent(scene);\r\n        scene._addComponent(compo);\r\n    }\r\n};\r\n"],
  "mappings": "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",
  "names": ["transformNode"]
}
