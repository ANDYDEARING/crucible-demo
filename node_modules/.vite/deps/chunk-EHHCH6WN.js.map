{
  "version": 3,
  "sources": ["../../../dev/gui/src/2D/controls/textBlock.ts"],
  "sourcesContent": ["import { Observable } from \"core/Misc/observable\";\r\nimport type { Measure } from \"../measure\";\r\nimport { ValueAndUnit } from \"../valueAndUnit\";\r\nimport { Control } from \"./control\";\r\nimport { RegisterClass } from \"core/Misc/typeStore\";\r\nimport type { Nullable } from \"core/types\";\r\nimport { serialize } from \"core/Misc/decorators\";\r\nimport type { ICanvasRenderingContext, ITextMetrics } from \"core/Engines/ICanvas\";\r\nimport { EngineStore } from \"core/Engines/engineStore\";\r\n\r\n/**\r\n * Enum that determines the text-wrapping mode to use.\r\n */\r\nexport const enum TextWrapping {\r\n    /**\r\n     * Clip the text when it's larger than Control.width; this is the default mode.\r\n     */\r\n    Clip = 0,\r\n\r\n    /**\r\n     * Wrap the text word-wise, i.e. try to add line-breaks at word boundary to fit within Control.width.\r\n     */\r\n    WordWrap = 1,\r\n\r\n    /**\r\n     * Ellipsize the text, i.e. shrink with trailing … when text is larger than Control.width.\r\n     */\r\n    Ellipsis = 2,\r\n\r\n    /**\r\n     * Wrap the text word-wise and clip the text when the text's height is larger than the Control.height, and shrink the last line with trailing … .\r\n     */\r\n    WordWrapEllipsis = 3,\r\n\r\n    /**\r\n     * Use HTML to wrap the text. This is the only mode that supports east-asian languages.\r\n     */\r\n    HTML = 4,\r\n}\r\n\r\n/**\r\n * Class used to create text block control\r\n */\r\nexport class TextBlock extends Control {\r\n    private _text = \"\";\r\n    private _textWrapping = TextWrapping.Clip;\r\n    private _textHorizontalAlignment = Control.HORIZONTAL_ALIGNMENT_CENTER;\r\n    private _textVerticalAlignment = Control.VERTICAL_ALIGNMENT_CENTER;\r\n\r\n    private _lines: any[];\r\n    private _resizeToFit: boolean = false;\r\n    private _lineSpacing: ValueAndUnit = new ValueAndUnit(0);\r\n    private _outlineWidth: number = 0;\r\n    private _outlineColor: string = \"white\";\r\n    private _underline: boolean = false;\r\n    private _lineThrough: boolean = false;\r\n    private _wordDivider: string = \" \";\r\n    private _forceResizeWidth: boolean = false;\r\n    private _applyOutlineToUnderline: boolean = false;\r\n\r\n    /**\r\n     * An event triggered after the text is changed\r\n     */\r\n    public onTextChangedObservable = new Observable<TextBlock>();\r\n\r\n    /**\r\n     * An event triggered after the text was broken up into lines\r\n     */\r\n    public onLinesReadyObservable = new Observable<TextBlock>();\r\n\r\n    /**\r\n     * Function used to split a string into words. By default, a string is split at each space character found\r\n     */\r\n    public wordSplittingFunction: Nullable<(line: string) => string[]>;\r\n\r\n    /**\r\n     * This function will be called when a new HTML element is generated to be used for word wrapping.\r\n     * This is only used when wrapping mode HTML is selected.\r\n     * Using this function you can adjust word-break, overflow-wrap, hyphens, or any other CSS properties of the HTML element, language-dependent.\r\n     */\r\n    public adjustWordWrappingHTMLElement: Nullable<(element: HTMLElement) => void>;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the HTML element generated for word wrapping should be reused or removed after each wrapping.\r\n     */\r\n    public reuseHTMLForWordWrapping: boolean = false;\r\n\r\n    /**\r\n     * Return the line list (you may need to use the onLinesReadyObservable to make sure the list is ready)\r\n     */\r\n    public get lines(): any[] {\r\n        return this._lines;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that the TextBlock will be resized to fit its content\r\n\r\n     */\r\n    @serialize()\r\n    public get resizeToFit(): boolean {\r\n        return this._resizeToFit;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that the TextBlock will be resized to fit its content\r\n\r\n     */\r\n    public set resizeToFit(value: boolean) {\r\n        if (this._resizeToFit === value) {\r\n            return;\r\n        }\r\n        this._resizeToFit = value;\r\n\r\n        if (this._resizeToFit) {\r\n            this._width.ignoreAdaptiveScaling = true;\r\n            this._height.ignoreAdaptiveScaling = true;\r\n        }\r\n\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if text must be wrapped\r\n     */\r\n    @serialize()\r\n    public get textWrapping(): TextWrapping | boolean {\r\n        return this._textWrapping;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if text must be wrapped\r\n     */\r\n    public set textWrapping(value: TextWrapping | boolean) {\r\n        if (this._textWrapping === value) {\r\n            return;\r\n        }\r\n        this._textWrapping = +value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets text to display\r\n     */\r\n    @serialize()\r\n    public get text(): string {\r\n        return this._text;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets text to display\r\n     */\r\n    public set text(value: string) {\r\n        if (this._text === value) {\r\n            return;\r\n        }\r\n        this._text = value + \"\"; // Making sure it is a text\r\n        this._markAsDirty();\r\n\r\n        this.onTextChangedObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets text horizontal alignment (BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER by default)\r\n     */\r\n    @serialize()\r\n    public get textHorizontalAlignment(): number {\r\n        return this._textHorizontalAlignment;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets text horizontal alignment (BABYLON.GUI.Control.HORIZONTAL_ALIGNMENT_CENTER by default)\r\n     */\r\n    public set textHorizontalAlignment(value: number) {\r\n        if (this._textHorizontalAlignment === value) {\r\n            return;\r\n        }\r\n\r\n        this._textHorizontalAlignment = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets text vertical alignment (BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER by default)\r\n     */\r\n    @serialize()\r\n    public get textVerticalAlignment(): number {\r\n        return this._textVerticalAlignment;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets text vertical alignment (BABYLON.GUI.Control.VERTICAL_ALIGNMENT_CENTER by default)\r\n     */\r\n    public set textVerticalAlignment(value: number) {\r\n        if (this._textVerticalAlignment === value) {\r\n            return;\r\n        }\r\n\r\n        this._textVerticalAlignment = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets line spacing value\r\n     */\r\n    @serialize()\r\n    public set lineSpacing(value: string | number) {\r\n        if (this._lineSpacing.fromString(value)) {\r\n            this._markAsDirty();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets line spacing value\r\n     */\r\n    public get lineSpacing(): string | number {\r\n        return this._lineSpacing.toString(this._host);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets outlineWidth of the text to display\r\n     */\r\n    @serialize()\r\n    public get outlineWidth(): number {\r\n        return this._outlineWidth;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets outlineWidth of the text to display\r\n     */\r\n    public set outlineWidth(value: number) {\r\n        if (this._outlineWidth === value) {\r\n            return;\r\n        }\r\n        this._outlineWidth = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that text must have underline\r\n     */\r\n    @serialize()\r\n    public get underline(): boolean {\r\n        return this._underline;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating that text must have underline\r\n     */\r\n    public set underline(value: boolean) {\r\n        if (this._underline === value) {\r\n            return;\r\n        }\r\n        this._underline = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets an boolean indicating that text must be crossed out\r\n     */\r\n    @serialize()\r\n    public get lineThrough(): boolean {\r\n        return this._lineThrough;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets an boolean indicating that text must be crossed out\r\n     */\r\n    public set lineThrough(value: boolean) {\r\n        if (this._lineThrough === value) {\r\n            return;\r\n        }\r\n        this._lineThrough = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * If the outline should be applied to the underline/strike-through too. Has different behavior in Edge/Chrome vs Firefox.\r\n     */\r\n    @serialize()\r\n    public get applyOutlineToUnderline(): boolean {\r\n        return this._applyOutlineToUnderline;\r\n    }\r\n\r\n    public set applyOutlineToUnderline(value: boolean) {\r\n        if (this._applyOutlineToUnderline === value) {\r\n            return;\r\n        }\r\n        this._applyOutlineToUnderline = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets outlineColor of the text to display\r\n     */\r\n    @serialize()\r\n    public get outlineColor(): string {\r\n        return this._outlineColor;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets outlineColor of the text to display\r\n     */\r\n    public set outlineColor(value: string) {\r\n        if (this._outlineColor === value) {\r\n            return;\r\n        }\r\n        this._outlineColor = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Gets or sets word divider\r\n     */\r\n    @serialize()\r\n    public get wordDivider(): string {\r\n        return this._wordDivider;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets word divider\r\n     */\r\n    public set wordDivider(value: string) {\r\n        if (this._wordDivider === value) {\r\n            return;\r\n        }\r\n        this._wordDivider = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * By default, if a text block has text wrapping other than Clip, its width\r\n     * is not resized even if resizeToFit = true. This parameter forces the width\r\n     * to be resized.\r\n     */\r\n    @serialize()\r\n    public get forceResizeWidth(): boolean {\r\n        return this._forceResizeWidth;\r\n    }\r\n\r\n    public set forceResizeWidth(value: boolean) {\r\n        if (this._forceResizeWidth === value) {\r\n            return;\r\n        }\r\n        this._forceResizeWidth = value;\r\n        this._markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Creates a new TextBlock object\r\n     * @param name defines the name of the control\r\n     * @param text defines the text to display (empty string by default)\r\n     */\r\n    constructor(\r\n        /**\r\n         * Defines the name of the control\r\n         */\r\n        public override name?: string,\r\n        text: string = \"\"\r\n    ) {\r\n        super(name);\r\n\r\n        this.text = text;\r\n    }\r\n\r\n    protected override _getTypeName(): string {\r\n        return \"TextBlock\";\r\n    }\r\n\r\n    protected override _processMeasures(parentMeasure: Measure, context: ICanvasRenderingContext): void {\r\n        super._processMeasures(parentMeasure, context);\r\n\r\n        // Apply states so we can use the right font to measure\r\n        context.save();\r\n        this._applyStates(context);\r\n\r\n        // Measure the font\r\n        if (!this._fontOffset || this.isDirty) {\r\n            this._fontOffset = Control._GetFontOffset(context.font, this._host.getScene()?.getEngine());\r\n        }\r\n\r\n        // Prepare lines\r\n        this._lines = this._breakLines(this._currentMeasure.width, this._currentMeasure.height, context);\r\n        this.onLinesReadyObservable.notifyObservers(this);\r\n\r\n        // Restore context now that we're done measuring the font\r\n        context.restore();\r\n\r\n        let maxLineWidth: number = 0;\r\n\r\n        for (let i = 0; i < this._lines.length; i++) {\r\n            const line = this._lines[i];\r\n\r\n            if (line.width > maxLineWidth) {\r\n                maxLineWidth = line.width;\r\n            }\r\n        }\r\n\r\n        if (this._resizeToFit) {\r\n            if (this._textWrapping === TextWrapping.Clip || this._forceResizeWidth) {\r\n                const newWidth = Math.ceil(this._paddingLeftInPixels) + Math.ceil(this._paddingRightInPixels) + Math.ceil(maxLineWidth);\r\n                if (newWidth !== this._width.getValueInPixel(this._host, this._tempParentMeasure.width)) {\r\n                    this._width.updateInPlace(newWidth, ValueAndUnit.UNITMODE_PIXEL);\r\n                    this._rebuildLayout = true;\r\n                }\r\n            }\r\n            let newHeight = (this._paddingTopInPixels + this._paddingBottomInPixels + this._fontOffset.height * this._lines.length) | 0;\r\n\r\n            if (this._lines.length > 0 && this._lineSpacing.internalValue !== 0) {\r\n                let lineSpacing = 0;\r\n                if (this._lineSpacing.isPixel) {\r\n                    lineSpacing = this._lineSpacing.getValue(this._host);\r\n                } else {\r\n                    lineSpacing = this._lineSpacing.getValue(this._host) * this._height.getValueInPixel(this._host, this._cachedParentMeasure.height);\r\n                }\r\n\r\n                newHeight += (this._lines.length - 1) * lineSpacing;\r\n            }\r\n\r\n            if (newHeight !== this._height.internalValue) {\r\n                this._height.updateInPlace(newHeight, ValueAndUnit.UNITMODE_PIXEL);\r\n                this._rebuildLayout = true;\r\n            }\r\n        }\r\n    }\r\n\r\n    private _drawText(text: string, textWidth: number, y: number, context: ICanvasRenderingContext): void {\r\n        const width = this._currentMeasure.width;\r\n        let x = 0;\r\n        switch (this._textHorizontalAlignment) {\r\n            case Control.HORIZONTAL_ALIGNMENT_LEFT:\r\n                x = 0;\r\n                break;\r\n            case Control.HORIZONTAL_ALIGNMENT_RIGHT:\r\n                x = width - textWidth;\r\n                break;\r\n            case Control.HORIZONTAL_ALIGNMENT_CENTER:\r\n                x = (width - textWidth) / 2;\r\n                break;\r\n        }\r\n\r\n        if (this.shadowBlur || this.shadowOffsetX || this.shadowOffsetY) {\r\n            context.shadowColor = this.shadowColor;\r\n            context.shadowBlur = this.shadowBlur;\r\n            const idealRatio = this.host.idealRatio;\r\n            context.shadowOffsetX = this.shadowOffsetX * idealRatio;\r\n            context.shadowOffsetY = this.shadowOffsetY * idealRatio;\r\n        }\r\n\r\n        if (this.outlineWidth) {\r\n            context.strokeText(text, this._currentMeasure.left + x, y);\r\n        }\r\n        context.fillText(text, this._currentMeasure.left + x, y);\r\n\r\n        if (this._underline) {\r\n            this._drawLine(this._currentMeasure.left + x, y + 3, this._currentMeasure.left + x + textWidth, y + 3, context);\r\n        }\r\n\r\n        if (this._lineThrough) {\r\n            this._drawLine(this._currentMeasure.left + x, y - this.fontSizeInPixels / 3, this._currentMeasure.left + x + textWidth, y - this.fontSizeInPixels / 3, context);\r\n        }\r\n    }\r\n\r\n    private _drawLine(xFrom: number, yFrom: number, xTo: number, yTo: number, context: ICanvasRenderingContext): void {\r\n        context.beginPath();\r\n        context.lineWidth = Math.round(this.fontSizeInPixels * 0.05);\r\n        context.moveTo(xFrom, yFrom);\r\n        context.lineTo(xTo, yTo);\r\n        if (this.outlineWidth && this.applyOutlineToUnderline) {\r\n            context.stroke();\r\n            context.fill();\r\n        } else {\r\n            const currentStroke = context.strokeStyle;\r\n            context.strokeStyle = context.fillStyle;\r\n            context.stroke();\r\n            context.strokeStyle = currentStroke;\r\n        }\r\n        context.closePath();\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    public override _draw(context: ICanvasRenderingContext): void {\r\n        context.save();\r\n\r\n        this._applyStates(context);\r\n\r\n        // Render lines\r\n        this._renderLines(context);\r\n\r\n        context.restore();\r\n    }\r\n\r\n    protected override _applyStates(context: ICanvasRenderingContext): void {\r\n        super._applyStates(context);\r\n        if (this.outlineWidth) {\r\n            context.lineWidth = this.outlineWidth;\r\n            context.strokeStyle = this.outlineColor;\r\n            context.lineJoin = \"miter\";\r\n            context.miterLimit = 2;\r\n        }\r\n    }\r\n\r\n    private _linesTemp: object[] = [];\r\n\r\n    protected _breakLines(refWidth: number, refHeight: number, context: ICanvasRenderingContext): object[] {\r\n        this._linesTemp.length = 0;\r\n        const _lines = this._textWrapping === TextWrapping.HTML ? this._parseHTMLText(refWidth, refHeight, context) : this.text.split(\"\\n\");\r\n\r\n        switch (this._textWrapping) {\r\n            case TextWrapping.WordWrap:\r\n                for (const _line of _lines) {\r\n                    this._linesTemp.push(...this._parseLineWordWrap(_line, refWidth, context));\r\n                }\r\n                break;\r\n            case TextWrapping.Ellipsis:\r\n                for (const _line of _lines) {\r\n                    this._linesTemp.push(this._parseLineEllipsis(_line, refWidth, context));\r\n                }\r\n                break;\r\n            case TextWrapping.WordWrapEllipsis:\r\n                for (const _line of _lines) {\r\n                    this._linesTemp.push(...this._parseLineWordWrapEllipsis(_line, refWidth, refHeight, context));\r\n                }\r\n                break;\r\n            case TextWrapping.HTML:\r\n            default:\r\n                for (const _line of _lines) {\r\n                    this._linesTemp.push(this._parseLine(_line, context));\r\n                }\r\n                break;\r\n        }\r\n\r\n        return this._linesTemp;\r\n    }\r\n\r\n    private _htmlElement: Nullable<HTMLElement> = null;\r\n\r\n    protected _parseHTMLText(refWidth: number, refHeight: number, context: ICanvasRenderingContext): string[] {\r\n        const lines = [] as string[];\r\n        if (!this._htmlElement) {\r\n            this._htmlElement = document.createElement(\"div\");\r\n            document.body.appendChild(this._htmlElement);\r\n        }\r\n        const htmlElement = this._htmlElement;\r\n        htmlElement.textContent = this.text;\r\n        htmlElement.style.font = context.font;\r\n        htmlElement.style.position = \"absolute\";\r\n        htmlElement.style.visibility = \"hidden\";\r\n        htmlElement.style.top = \"-1000px\";\r\n        htmlElement.style.left = \"-1000px\";\r\n        this.adjustWordWrappingHTMLElement?.(htmlElement);\r\n        htmlElement.style.width = refWidth + \"px\";\r\n        htmlElement.style.height = refHeight + \"px\";\r\n        const textContent = htmlElement.textContent;\r\n        if (!textContent) {\r\n            return lines;\r\n        }\r\n        // get the text node\r\n        const textNode = htmlElement.childNodes[0];\r\n        const range = document.createRange();\r\n        let idx = 0;\r\n        for (const c of textContent) {\r\n            range.setStart(textNode, 0);\r\n            range.setEnd(textNode, idx + 1);\r\n            // \"select\" text from beginning to this position to determine the line\r\n            const lineIndex = range.getClientRects().length - 1;\r\n            lines[lineIndex] = (lines[lineIndex] || \"\") + c;\r\n            idx++;\r\n        }\r\n\r\n        if (!this.reuseHTMLForWordWrapping) {\r\n            htmlElement.remove();\r\n            this._htmlElement = null;\r\n        }\r\n\r\n        return lines;\r\n    }\r\n\r\n    protected _parseLine(line: string = \"\", context: ICanvasRenderingContext): object {\r\n        return { text: line, width: this._getTextMetricsWidth(context.measureText(line)) };\r\n    }\r\n\r\n    //Calculate how many characters approximately we need to remove\r\n    private _getCharsToRemove(lineWidth: number, width: number, lineLength: number) {\r\n        const diff = lineWidth > width ? lineWidth - width : 0;\r\n        // This isn't exact unless the font is monospaced\r\n        const charWidth = lineWidth / lineLength;\r\n        const removeChars = Math.max(Math.floor(diff / charWidth), 1);\r\n        return removeChars;\r\n    }\r\n\r\n    protected _parseLineEllipsis(line: string = \"\", width: number, context: ICanvasRenderingContext): object {\r\n        let lineWidth = this._getTextMetricsWidth(context.measureText(line));\r\n\r\n        let removeChars = this._getCharsToRemove(lineWidth, width, line.length);\r\n\r\n        // unicode support. split('') does not work with unicode!\r\n        // make sure Array.from is available\r\n        const characters = Array.from && Array.from(line);\r\n        if (!characters) {\r\n            // no array.from, use the old method\r\n            while (line.length > 2 && lineWidth > width) {\r\n                line = line.slice(0, -removeChars);\r\n                lineWidth = this._getTextMetricsWidth(context.measureText(line + \"…\"));\r\n\r\n                removeChars = this._getCharsToRemove(lineWidth, width, line.length);\r\n            }\r\n            // Add on the end\r\n            line += \"…\";\r\n        } else {\r\n            while (characters.length && lineWidth > width) {\r\n                characters.splice(characters.length - removeChars, removeChars);\r\n                line = `${characters.join(\"\")}…`;\r\n                lineWidth = this._getTextMetricsWidth(context.measureText(line));\r\n\r\n                removeChars = this._getCharsToRemove(lineWidth, width, line.length);\r\n            }\r\n        }\r\n\r\n        return { text: line, width: lineWidth };\r\n    }\r\n\r\n    private _getTextMetricsWidth(textMetrics: ITextMetrics) {\r\n        if (textMetrics.actualBoundingBoxLeft !== undefined) {\r\n            return Math.abs(textMetrics.actualBoundingBoxLeft) + Math.abs(textMetrics.actualBoundingBoxRight);\r\n        }\r\n        return textMetrics.width;\r\n    }\r\n\r\n    protected _parseLineWordWrap(line: string = \"\", width: number, context: ICanvasRenderingContext): object[] {\r\n        const lines = [];\r\n        const words = this.wordSplittingFunction ? this.wordSplittingFunction(line) : line.split(this._wordDivider);\r\n        let lineWidth = this._getTextMetricsWidth(context.measureText(line));\r\n\r\n        for (let n = 0; n < words.length; n++) {\r\n            const testLine = n > 0 ? line + this._wordDivider + words[n] : words[0];\r\n            const testWidth = this._getTextMetricsWidth(context.measureText(testLine));\r\n            if (testWidth > width && n > 0) {\r\n                lines.push({ text: line, width: lineWidth });\r\n                line = words[n];\r\n                lineWidth = this._getTextMetricsWidth(context.measureText(line));\r\n            } else {\r\n                lineWidth = testWidth;\r\n                line = testLine;\r\n            }\r\n        }\r\n        lines.push({ text: line, width: lineWidth });\r\n\r\n        return lines;\r\n    }\r\n\r\n    protected _parseLineWordWrapEllipsis(line: string = \"\", width: number, height: number, context: ICanvasRenderingContext): object[] {\r\n        const lines = this._parseLineWordWrap(line, width, context);\r\n        for (let n = 1; n <= lines.length; n++) {\r\n            const currentHeight = this._computeHeightForLinesOf(n);\r\n            if (currentHeight > height && n > 1) {\r\n                const lastLine = lines[n - 2] as { text: string; width: number };\r\n                const currentLine = lines[n - 1] as { text: string; width: number };\r\n                lines[n - 2] = this._parseLineEllipsis(lastLine.text + this._wordDivider + currentLine.text, width, context);\r\n                const linesToRemove = lines.length - n + 1;\r\n                for (let i = 0; i < linesToRemove; i++) {\r\n                    lines.pop();\r\n                }\r\n                return lines;\r\n            }\r\n        }\r\n\r\n        return lines;\r\n    }\r\n\r\n    protected _renderLines(context: ICanvasRenderingContext): void {\r\n        if (!this._fontOffset || !this._lines) {\r\n            return;\r\n        }\r\n        const height = this._currentMeasure.height;\r\n        let rootY = 0;\r\n        switch (this._textVerticalAlignment) {\r\n            case Control.VERTICAL_ALIGNMENT_TOP:\r\n                rootY = this._fontOffset.ascent;\r\n                break;\r\n            case Control.VERTICAL_ALIGNMENT_BOTTOM:\r\n                rootY = height - this._fontOffset.height * (this._lines.length - 1) - this._fontOffset.descent;\r\n                break;\r\n            case Control.VERTICAL_ALIGNMENT_CENTER:\r\n                rootY = this._fontOffset.ascent + (height - this._fontOffset.height * this._lines.length) / 2;\r\n                break;\r\n        }\r\n\r\n        rootY += this._currentMeasure.top;\r\n\r\n        for (let i = 0; i < this._lines.length; i++) {\r\n            const line = this._lines[i];\r\n\r\n            if (i !== 0 && this._lineSpacing.internalValue !== 0) {\r\n                if (this._lineSpacing.isPixel) {\r\n                    rootY += this._lineSpacing.getValue(this._host);\r\n                } else {\r\n                    rootY = rootY + this._lineSpacing.getValue(this._host) * this._height.getValueInPixel(this._host, this._cachedParentMeasure.height);\r\n                }\r\n            }\r\n\r\n            this._drawText(line.text, line.width, rootY, context);\r\n            rootY += this._fontOffset.height;\r\n        }\r\n    }\r\n\r\n    private _computeHeightForLinesOf(lineCount: number): number {\r\n        let newHeight = this._paddingTopInPixels + this._paddingBottomInPixels + this._fontOffset.height * lineCount;\r\n\r\n        if (lineCount > 0 && this._lineSpacing.internalValue !== 0) {\r\n            let lineSpacing = 0;\r\n            if (this._lineSpacing.isPixel) {\r\n                lineSpacing = this._lineSpacing.getValue(this._host);\r\n            } else {\r\n                lineSpacing = this._lineSpacing.getValue(this._host) * this._height.getValueInPixel(this._host, this._cachedParentMeasure.height);\r\n            }\r\n\r\n            newHeight += (lineCount - 1) * lineSpacing;\r\n        }\r\n\r\n        return newHeight;\r\n    }\r\n\r\n    public override isDimensionFullyDefined(dim: \"width\" | \"height\"): boolean {\r\n        if (this.resizeToFit) {\r\n            return true;\r\n        }\r\n        return super.isDimensionFullyDefined(dim);\r\n    }\r\n\r\n    /**\r\n     * Given a width constraint applied on the text block, find the expected height\r\n     * @returns expected height\r\n     */\r\n    public computeExpectedHeight(): number {\r\n        if (this.text && this.widthInPixels) {\r\n            // Should abstract platform instead of using LastCreatedEngine\r\n            const context = EngineStore.LastCreatedEngine?.createCanvas(0, 0).getContext(\"2d\");\r\n            if (context) {\r\n                // This is a temporary context, no need to save/restore\r\n                // eslint-disable-next-line babylonjs/require-context-save-before-apply-states\r\n                this._applyStates(context);\r\n                if (!this._fontOffset) {\r\n                    this._fontOffset = Control._GetFontOffset(context.font, this._host.getScene()?.getEngine());\r\n                }\r\n                const lines = this._lines\r\n                    ? this._lines\r\n                    : this._breakLines(\r\n                          this.widthInPixels - this._paddingLeftInPixels - this._paddingRightInPixels,\r\n                          this.heightInPixels - this._paddingTopInPixels - this._paddingBottomInPixels,\r\n                          context\r\n                      );\r\n                return this._computeHeightForLinesOf(lines.length);\r\n            }\r\n        }\r\n        return 0;\r\n    }\r\n\r\n    override dispose(): void {\r\n        super.dispose();\r\n\r\n        this.onTextChangedObservable.clear();\r\n        this._htmlElement?.remove();\r\n        this._htmlElement = null;\r\n    }\r\n}\r\nRegisterClass(\"BABYLON.GUI.TextBlock\", TextBlock);\r\n"],
  "mappings": "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",
  "names": ["TextWrapping"]
}
