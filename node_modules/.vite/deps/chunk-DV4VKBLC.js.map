{
  "version": 3,
  "sources": ["../../../dev/gui/src/2D/style.ts", "../../../dev/gui/src/2D/advancedDynamicTexture.ts"],
  "sourcesContent": ["import { Observable } from \"core/Misc/observable\";\r\nimport type { IDisposable } from \"core/scene\";\r\nimport type { AdvancedDynamicTexture } from \"./advancedDynamicTexture\";\r\nimport { ValueAndUnit } from \"./valueAndUnit\";\r\n\r\n/**\r\n * Define a style used by control to automatically setup properties based on a template.\r\n * Only support font related properties so far\r\n */\r\nexport class Style implements IDisposable {\r\n    private _fontFamily = \"Arial\";\r\n    private _fontStyle = \"\";\r\n    private _fontWeight = \"\";\r\n    /** @internal */\r\n    public _host: AdvancedDynamicTexture;\r\n    /** @internal */\r\n    public _fontSize = new ValueAndUnit(18, ValueAndUnit.UNITMODE_PIXEL, false);\r\n\r\n    /**\r\n     * Observable raised when the style values are changed\r\n     */\r\n    public onChangedObservable = new Observable<Style>();\r\n\r\n    /**\r\n     * Creates a new style object\r\n     * @param host defines the AdvancedDynamicTexture which hosts this style\r\n     */\r\n    public constructor(host: AdvancedDynamicTexture) {\r\n        this._host = host;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the font size\r\n     */\r\n    public get fontSize(): string | number {\r\n        return this._fontSize.toString(this._host);\r\n    }\r\n\r\n    public set fontSize(value: string | number) {\r\n        if (this._fontSize.toString(this._host) === value) {\r\n            return;\r\n        }\r\n\r\n        if (this._fontSize.fromString(value)) {\r\n            this.onChangedObservable.notifyObservers(this);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the font family\r\n     */\r\n    public get fontFamily(): string {\r\n        return this._fontFamily;\r\n    }\r\n\r\n    public set fontFamily(value: string) {\r\n        if (this._fontFamily === value) {\r\n            return;\r\n        }\r\n\r\n        this._fontFamily = value;\r\n        this.onChangedObservable.notifyObservers(this);\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the font style\r\n     */\r\n    public get fontStyle(): string {\r\n        return this._fontStyle;\r\n    }\r\n\r\n    public set fontStyle(value: string) {\r\n        if (this._fontStyle === value) {\r\n            return;\r\n        }\r\n\r\n        this._fontStyle = value;\r\n        this.onChangedObservable.notifyObservers(this);\r\n    }\r\n\r\n    /** Gets or sets font weight */\r\n    public get fontWeight(): string {\r\n        return this._fontWeight;\r\n    }\r\n\r\n    public set fontWeight(value: string) {\r\n        if (this._fontWeight === value) {\r\n            return;\r\n        }\r\n\r\n        this._fontWeight = value;\r\n        this.onChangedObservable.notifyObservers(this);\r\n    }\r\n\r\n    /** Dispose all associated resources */\r\n    public dispose() {\r\n        this.onChangedObservable.clear();\r\n    }\r\n}\r\n", "import type { Nullable } from \"core/types\";\r\nimport type { Observer } from \"core/Misc/observable\";\r\nimport { Observable } from \"core/Misc/observable\";\r\nimport type { Matrix } from \"core/Maths/math.vector\";\r\nimport { Vector2, Vector3, TmpVectors } from \"core/Maths/math.vector\";\r\nimport { Tools } from \"core/Misc/tools\";\r\nimport type { PointerInfoPre, PointerInfo, PointerInfoBase } from \"core/Events/pointerEvents\";\r\nimport { PointerEventTypes } from \"core/Events/pointerEvents\";\r\nimport { ClipboardEventTypes, ClipboardInfo } from \"core/Events/clipboardEvents\";\r\nimport type { KeyboardInfoPre } from \"core/Events/keyboardEvents\";\r\nimport { KeyboardEventTypes } from \"core/Events/keyboardEvents\";\r\nimport type { Camera } from \"core/Cameras/camera\";\r\nimport { Texture } from \"core/Materials/Textures/texture\";\r\nimport type { IDynamicTextureOptions } from \"core/Materials/Textures/dynamicTexture\";\r\nimport { DynamicTexture } from \"core/Materials/Textures/dynamicTexture\";\r\nimport type { AbstractMesh } from \"core/Meshes/abstractMesh\";\r\nimport { Layer } from \"core/Layers/layer\";\r\nimport type { Scene } from \"core/scene\";\r\n\r\nimport { Container } from \"./controls/container\";\r\nimport { Control } from \"./controls/control\";\r\nimport { Style } from \"./style\";\r\nimport { Measure } from \"./measure\";\r\nimport { Constants } from \"core/Engines/constants\";\r\nimport { Viewport } from \"core/Maths/math.viewport\";\r\nimport { Color3 } from \"core/Maths/math.color\";\r\nimport { WebRequest } from \"core/Misc/webRequest\";\r\nimport type { IPointerEvent, IWheelEvent } from \"core/Events/deviceInputEvents\";\r\nimport { RandomGUID } from \"core/Misc/guid\";\r\nimport { GetClass } from \"core/Misc/typeStore\";\r\nimport { DecodeBase64ToBinary } from \"core/Misc/stringTools\";\r\n\r\nimport type { StandardMaterial } from \"core/Materials/standardMaterial\";\r\nimport type { AbstractEngine } from \"core/Engines/abstractEngine\";\r\n\r\n/**\r\n * Interface used to define options to create an AdvancedDynamicTexture\r\n */\r\nexport interface IAdvancedDynamicTextureOptions extends IDynamicTextureOptions {\r\n    /**\r\n     * Indicates whether the ADT will be used autonomously. In this mode:\r\n     * - _checkUpdate() is not called\r\n     * - the layer is not rendered (so, the ADT is not visible)\r\n     * It's up to the user to perform the required calls manually to update the ADT.\r\n     */\r\n    useStandalone?: boolean;\r\n}\r\n\r\n/**\r\n * Class used to create texture to support 2D GUI elements\r\n * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui\r\n */\r\nexport class AdvancedDynamicTexture extends DynamicTexture {\r\n    /** Define the url to load snippets */\r\n    public static SnippetUrl = Constants.SnippetUrl;\r\n\r\n    /** Indicates if some optimizations can be performed in GUI GPU management (the downside is additional memory/GPU texture memory used) */\r\n    public static AllowGPUOptimizations = true;\r\n\r\n    /** Indicates whether the ADT is used autonomously */\r\n    public readonly useStandalone: boolean = false;\r\n\r\n    /** Snippet ID if the content was created from the snippet server */\r\n    public snippetId: string;\r\n\r\n    /** Observable that fires when the GUI is ready */\r\n    public onGuiReadyObservable = new Observable<AdvancedDynamicTexture>();\r\n\r\n    private _isDirty = false;\r\n    private _renderObserver: Nullable<Observer<Camera>>;\r\n    private _resizeObserver: Nullable<Observer<AbstractEngine>>;\r\n    private _preKeyboardObserver: Nullable<Observer<KeyboardInfoPre>>;\r\n    private _prePointerObserver: Nullable<Observer<PointerInfoPre>>;\r\n    private _sceneRenderObserver: Nullable<Observer<Scene>>;\r\n    private _pointerObserver: Nullable<Observer<PointerInfo>>;\r\n    private _canvasPointerOutObserver: Nullable<Observer<PointerEvent>>;\r\n    private _canvasBlurObserver: Nullable<Observer<AbstractEngine>>;\r\n    private _controlAddedObserver: Nullable<Observer<Nullable<Control>>>;\r\n    private _controlRemovedObserver: Nullable<Observer<Nullable<Control>>>;\r\n    private _background: string;\r\n    /** @internal */\r\n    public _rootContainer = new Container(\"root\");\r\n    /** @internal */\r\n    public _lastPickedControl: Control;\r\n    /** @internal */\r\n    public _lastControlOver: { [pointerId: number]: Control } = {};\r\n    /** @internal */\r\n    public _lastControlDown: { [pointerId: number]: Control } = {};\r\n    /** @internal */\r\n    public _capturingControl: { [pointerId: number]: Control } = {};\r\n    /** @internal */\r\n    public _shouldBlockPointer: boolean;\r\n    /** @internal */\r\n    public _layerToDispose: Nullable<Layer>;\r\n    /** @internal */\r\n    public _linkedControls = new Array<Control>();\r\n    /** @internal */\r\n    public _isFullscreen = false;\r\n    private _fullscreenViewport = new Viewport(0, 0, 1, 1);\r\n    private _idealWidth = 0;\r\n    private _idealHeight = 0;\r\n    private _useSmallestIdeal: boolean = false;\r\n    private _renderAtIdealSize = false;\r\n    private _focusedControl: Nullable<Control>;\r\n    private _blockNextFocusCheck = false;\r\n    private _renderScale = 1;\r\n    private _rootElement: Nullable<HTMLElement>;\r\n    private _cursorChanged = false;\r\n    private _defaultMousePointerId = 0;\r\n    private _rootChildrenHaveChanged: boolean = false;\r\n    private _adjustToEngineHardwareScalingLevel = false;\r\n\r\n    /** @internal */\r\n    public _capturedPointerIds = new Set<number>();\r\n\r\n    /** @internal */\r\n    public _numLayoutCalls = 0;\r\n    /** Gets the number of layout calls made the last time the ADT has been rendered */\r\n    public get numLayoutCalls(): number {\r\n        return this._numLayoutCalls;\r\n    }\r\n\r\n    /** @internal */\r\n    public _numRenderCalls = 0;\r\n    /** Gets the number of render calls made the last time the ADT has been rendered */\r\n    public get numRenderCalls(): number {\r\n        return this._numRenderCalls;\r\n    }\r\n\r\n    /**\r\n     * Define type to string to ensure compatibility across browsers\r\n     * Safari doesn't support DataTransfer constructor\r\n     */\r\n    private _clipboardData: string = \"\";\r\n    /**\r\n     * Observable event triggered each time an clipboard event is received from the rendering canvas\r\n     */\r\n    public onClipboardObservable = new Observable<ClipboardInfo>();\r\n    /**\r\n     * Observable event triggered each time a pointer down is intercepted by a control\r\n     */\r\n    public onControlPickedObservable = new Observable<Control>();\r\n    /**\r\n     * Observable event triggered before layout is evaluated\r\n     */\r\n    public onBeginLayoutObservable = new Observable<AdvancedDynamicTexture>();\r\n    /**\r\n     * Observable event triggered after the layout was evaluated\r\n     */\r\n    public onEndLayoutObservable = new Observable<AdvancedDynamicTexture>();\r\n    /**\r\n     * Observable event triggered before the texture is rendered\r\n     */\r\n    public onBeginRenderObservable = new Observable<AdvancedDynamicTexture>();\r\n    /**\r\n     * Observable event triggered after the texture was rendered\r\n     */\r\n    public onEndRenderObservable = new Observable<AdvancedDynamicTexture>();\r\n    /**\r\n     * Gets or sets a boolean defining if alpha is stored as premultiplied\r\n     */\r\n    public premulAlpha = false;\r\n    /**\r\n     * Gets or sets a boolean indicating that the canvas must be reverted on Y when updating the texture\r\n     */\r\n    // eslint-disable-next-line @typescript-eslint/naming-convention\r\n    public applyYInversionOnUpdate = true;\r\n\r\n    /**\r\n     * A boolean indicating whether or not the elements can be navigated to using the tab key.\r\n     * Defaults to false.\r\n     */\r\n    public disableTabNavigation = false;\r\n\r\n    /**\r\n     * A boolean indicating whether controls can be picked/clicked on or not. Defaults to false.\r\n     */\r\n    public disablePicking = false;\r\n\r\n    /**\r\n     * If set to true, the POINTERTAP event type will be used for \"click\", instead of POINTERUP\r\n     */\r\n    public usePointerTapForClickEvent = false;\r\n\r\n    /**\r\n     * If set to true, the renderScale will be adjusted automatically to the engine's hardware scaling\r\n     * If this is set to true, manually setting the renderScale will be ignored\r\n     * This is useful when the engine's hardware scaling is set to a value other than 1\r\n     */\r\n    public get adjustToEngineHardwareScalingLevel(): boolean {\r\n        return this._adjustToEngineHardwareScalingLevel;\r\n    }\r\n\r\n    public set adjustToEngineHardwareScalingLevel(value: boolean) {\r\n        if (this._adjustToEngineHardwareScalingLevel === value) {\r\n            return;\r\n        }\r\n        this._adjustToEngineHardwareScalingLevel = value;\r\n        this._onResize();\r\n    }\r\n    /**\r\n     * Gets or sets a number used to scale rendering size (2 means that the texture will be twice bigger).\r\n     * Useful when you want more antialiasing\r\n     */\r\n    public get renderScale(): number {\r\n        return this._renderScale;\r\n    }\r\n    public set renderScale(value: number) {\r\n        if (value === this._renderScale) {\r\n            return;\r\n        }\r\n        this._renderScale = value;\r\n        this._onResize();\r\n    }\r\n    /** Gets or sets the background color */\r\n    public get background(): string {\r\n        return this._background;\r\n    }\r\n    public set background(value: string) {\r\n        if (this._background === value) {\r\n            return;\r\n        }\r\n        this._background = value;\r\n        this.markAsDirty();\r\n    }\r\n    /**\r\n     * Gets or sets the ideal width used to design controls.\r\n     * The GUI will then rescale everything accordingly\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#adaptive-scaling\r\n     */\r\n    public get idealWidth(): number {\r\n        return this._idealWidth;\r\n    }\r\n    public set idealWidth(value: number) {\r\n        if (this._idealWidth === value) {\r\n            return;\r\n        }\r\n        this._idealWidth = value;\r\n        this.markAsDirty();\r\n        this._rootContainer._markAllAsDirty();\r\n    }\r\n    /**\r\n     * Gets or sets the ideal height used to design controls.\r\n     * The GUI will then rescale everything accordingly\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#adaptive-scaling\r\n     */\r\n    public get idealHeight(): number {\r\n        return this._idealHeight;\r\n    }\r\n    public set idealHeight(value: number) {\r\n        if (this._idealHeight === value) {\r\n            return;\r\n        }\r\n        this._idealHeight = value;\r\n        this.markAsDirty();\r\n        this._rootContainer._markAllAsDirty();\r\n    }\r\n    /**\r\n     * Gets or sets a boolean indicating if the smallest ideal value must be used if idealWidth and idealHeight are both set\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#adaptive-scaling\r\n     */\r\n    public get useSmallestIdeal(): boolean {\r\n        return this._useSmallestIdeal;\r\n    }\r\n    public set useSmallestIdeal(value: boolean) {\r\n        if (this._useSmallestIdeal === value) {\r\n            return;\r\n        }\r\n        this._useSmallestIdeal = value;\r\n        this.markAsDirty();\r\n        this._rootContainer._markAllAsDirty();\r\n    }\r\n    /**\r\n     * Gets or sets a boolean indicating if adaptive scaling must be used\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#adaptive-scaling\r\n     */\r\n    public get renderAtIdealSize(): boolean {\r\n        return this._renderAtIdealSize;\r\n    }\r\n    public set renderAtIdealSize(value: boolean) {\r\n        if (this._renderAtIdealSize === value) {\r\n            return;\r\n        }\r\n        this._renderAtIdealSize = value;\r\n        this._onResize();\r\n    }\r\n\r\n    /**\r\n     * Gets the ratio used when in \"ideal mode\"\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#adaptive-scaling\r\n     * */\r\n    public get idealRatio(): number {\r\n        let rwidth: number = 0;\r\n        let rheight: number = 0;\r\n\r\n        if (this._idealWidth) {\r\n            rwidth = this.getSize().width / this._idealWidth;\r\n        }\r\n\r\n        if (this._idealHeight) {\r\n            rheight = this.getSize().height / this._idealHeight;\r\n        }\r\n\r\n        if (this._useSmallestIdeal && this._idealWidth && this._idealHeight) {\r\n            return window.innerWidth < window.innerHeight ? rwidth : rheight;\r\n        }\r\n\r\n        if (this._idealWidth) {\r\n            // horizontal\r\n            return rwidth;\r\n        }\r\n\r\n        if (this._idealHeight) {\r\n            // vertical\r\n            return rheight;\r\n        }\r\n\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * Gets the underlying layer used to render the texture when in fullscreen mode\r\n     */\r\n    public get layer(): Nullable<Layer> {\r\n        return this._layerToDispose;\r\n    }\r\n    /**\r\n     * Gets the root container control\r\n     */\r\n    public get rootContainer(): Container {\r\n        return this._rootContainer;\r\n    }\r\n    /**\r\n     * Returns an array containing the root container.\r\n     * This is mostly used to let the Inspector introspects the ADT\r\n     * @returns an array containing the rootContainer\r\n     */\r\n    public getChildren(): Array<Container> {\r\n        return [this._rootContainer];\r\n    }\r\n    /**\r\n     * Will return all controls that are inside this texture\r\n     * @param directDescendantsOnly defines if true only direct descendants of 'this' will be considered, if false direct and also indirect (children of children, an so on in a recursive manner) descendants of 'this' will be considered\r\n     * @param predicate defines an optional predicate that will be called on every evaluated child, the predicate must return true for a given child to be part of the result, otherwise it will be ignored\r\n     * @returns all child controls\r\n     */\r\n    public getDescendants(directDescendantsOnly?: boolean, predicate?: (control: Control) => boolean): Control[] {\r\n        return this._rootContainer.getDescendants(directDescendantsOnly, predicate);\r\n    }\r\n\r\n    /**\r\n     * Will return all controls with the given type name\r\n     * @param typeName defines the type name to search for\r\n     * @returns an array of all controls found\r\n     */\r\n    public getControlsByType(typeName: string): Control[] {\r\n        return this._rootContainer.getDescendants(false, (control) => control.typeName === typeName);\r\n    }\r\n\r\n    /**\r\n     * Will return the first control with the given name\r\n     * @param name defines the name to search for\r\n     * @returns the first control found or null\r\n     */\r\n    public getControlByName(name: string): Nullable<Control> {\r\n        return this._getControlByKey(\"name\", name);\r\n    }\r\n\r\n    private _getControlByKey(key: string, value: any): Nullable<Control> {\r\n        return this._rootContainer.getDescendants().find((control) => control[key as keyof Control] === value) || null;\r\n    }\r\n\r\n    /**\r\n     * Gets or sets the current focused control\r\n     */\r\n    public get focusedControl(): Nullable<Control> {\r\n        return this._focusedControl;\r\n    }\r\n    public set focusedControl(control: Nullable<Control>) {\r\n        if (this._focusedControl == control) {\r\n            return;\r\n        }\r\n        if (this._focusedControl) {\r\n            this._focusedControl.onBlur();\r\n        }\r\n        if (control) {\r\n            control.onFocus();\r\n        }\r\n        this._focusedControl = control;\r\n    }\r\n    /**\r\n     * Gets or sets a boolean indicating if the texture must be rendered in background or foreground when in fullscreen mode\r\n     */\r\n    public get isForeground(): boolean {\r\n        if (!this.layer) {\r\n            return true;\r\n        }\r\n        return !this.layer.isBackground;\r\n    }\r\n    public set isForeground(value: boolean) {\r\n        if (!this.layer) {\r\n            return;\r\n        }\r\n        if (this.layer.isBackground === !value) {\r\n            return;\r\n        }\r\n        this.layer.isBackground = !value;\r\n    }\r\n    /**\r\n     * Gets or set information about clipboardData\r\n     */\r\n    public get clipboardData(): string {\r\n        return this._clipboardData;\r\n    }\r\n    public set clipboardData(value: string) {\r\n        this._clipboardData = value;\r\n    }\r\n\r\n    /**\r\n     * If this is set, even when a control is pointer blocker, some events can still be passed through to the scene.\r\n     * Options from values are PointerEventTypes\r\n     * POINTERDOWN, POINTERUP, POINTERMOVE, POINTERWHEEL, POINTERPICK, POINTERTAP, POINTERDOUBLETAP\r\n     */\r\n    public skipBlockEvents = 0;\r\n\r\n    /**\r\n     * If set to true, every scene render will trigger a pointer event for the GUI\r\n     * if it is linked to a mesh or has controls linked to a mesh. This will allow\r\n     * you to catch the pointer moving around the GUI due to camera or mesh movements,\r\n     * but it has a performance cost.\r\n     */\r\n    public checkPointerEveryFrame = false;\r\n\r\n    /**\r\n     * Creates a new AdvancedDynamicTexture\r\n     * @param name defines the name of the texture\r\n     * @param options The options to be used when constructing the ADT\r\n     */\r\n    constructor(name: string, options?: IAdvancedDynamicTextureOptions);\r\n\r\n    constructor(name: string, width?: number, height?: number, scene?: Nullable<Scene>, generateMipMaps?: boolean, samplingMode?: number, invertY?: boolean);\r\n\r\n    /** @internal */\r\n    constructor(\r\n        name: string,\r\n        widthOrOptions?: number | IAdvancedDynamicTextureOptions,\r\n        _height = 0,\r\n        scene?: Nullable<Scene>,\r\n        generateMipMaps = false,\r\n        samplingMode = Texture.NEAREST_SAMPLINGMODE,\r\n        invertY = true\r\n    ) {\r\n        widthOrOptions = widthOrOptions ?? 0;\r\n\r\n        const width = typeof widthOrOptions === \"object\" && widthOrOptions !== undefined ? (widthOrOptions.width ?? 0) : (widthOrOptions ?? 0);\r\n        const height = typeof widthOrOptions === \"object\" && widthOrOptions !== undefined ? (widthOrOptions.height ?? 0) : _height;\r\n\r\n        super(\r\n            name,\r\n            { width, height },\r\n            typeof widthOrOptions === \"object\" && widthOrOptions !== undefined ? widthOrOptions : scene,\r\n            generateMipMaps,\r\n            samplingMode,\r\n            Constants.TEXTUREFORMAT_RGBA,\r\n            invertY\r\n        );\r\n\r\n        scene = this.getScene();\r\n        if (!scene || !this._texture) {\r\n            return;\r\n        }\r\n        this.applyYInversionOnUpdate = invertY;\r\n        this._rootElement = scene.getEngine().getInputElement();\r\n\r\n        const adtOptions = widthOrOptions as IAdvancedDynamicTextureOptions;\r\n\r\n        this.useStandalone = !!adtOptions?.useStandalone;\r\n\r\n        if (!this.useStandalone) {\r\n            this._renderObserver = scene.onBeforeCameraRenderObservable.add((camera: Camera) => this._checkUpdate(camera));\r\n        }\r\n\r\n        /** Whenever a control is added or removed to the root, we have to recheck the camera projection as it can have changed  */\r\n        this._controlAddedObserver = this._rootContainer.onControlAddedObservable.add((control) => {\r\n            if (control) {\r\n                this._rootChildrenHaveChanged = true;\r\n            }\r\n        });\r\n        this._controlRemovedObserver = this._rootContainer.onControlRemovedObservable.add((control) => {\r\n            if (control) {\r\n                this._rootChildrenHaveChanged = true;\r\n            }\r\n        });\r\n        this._preKeyboardObserver = scene.onPreKeyboardObservable.add((info) => {\r\n            // check if tab is pressed\r\n            if (!this.disableTabNavigation && info.type === KeyboardEventTypes.KEYDOWN && info.event.code === \"Tab\") {\r\n                const forward = !info.event.shiftKey;\r\n                if (\r\n                    (forward && this._focusProperties.index === this._focusProperties.total - 1) ||\r\n                    (!forward && this._focusProperties.index === 0 && this._focusProperties.total > 0)\r\n                ) {\r\n                    this.focusedControl = null;\r\n                    this._focusProperties.index = 0;\r\n                    this._focusProperties.total = -1;\r\n                    return;\r\n                }\r\n                this._focusNextElement(forward);\r\n                info.event.preventDefault();\r\n                return;\r\n            }\r\n            if (!this._focusedControl) {\r\n                return;\r\n            }\r\n            if (info.type === KeyboardEventTypes.KEYDOWN) {\r\n                this._focusedControl.processKeyboard(info.event);\r\n            }\r\n            info.skipOnPointerObservable = true;\r\n        });\r\n        this._rootContainer._link(this);\r\n        this.hasAlpha = true;\r\n        if (!width || !height) {\r\n            this._resizeObserver = scene.getEngine().onResizeObservable.add(() => this._onResize());\r\n            this._onResize();\r\n        }\r\n        this._texture.isReady = true;\r\n    }\r\n    /**\r\n     * Get the current class name of the texture useful for serialization or dynamic coding.\r\n     * @returns \"AdvancedDynamicTexture\"\r\n     */\r\n    public override getClassName(): string {\r\n        return \"AdvancedDynamicTexture\";\r\n    }\r\n    /**\r\n     * Function used to execute a function on all controls\r\n     * @param func defines the function to execute\r\n     * @param container defines the container where controls belong. If null the root container will be used\r\n     */\r\n    public executeOnAllControls(func: (control: Control) => void, container?: Container) {\r\n        if (!container) {\r\n            container = this._rootContainer;\r\n        }\r\n        func(container);\r\n        for (const child of container.children) {\r\n            if ((<any>child).children) {\r\n                this.executeOnAllControls(func, <Container>child);\r\n                continue;\r\n            }\r\n            func(child);\r\n        }\r\n    }\r\n\r\n    private _useInvalidateRectOptimization = true;\r\n\r\n    /**\r\n     * Gets or sets a boolean indicating if the InvalidateRect optimization should be turned on\r\n     */\r\n    public get useInvalidateRectOptimization(): boolean {\r\n        return this._useInvalidateRectOptimization;\r\n    }\r\n\r\n    public set useInvalidateRectOptimization(value: boolean) {\r\n        this._useInvalidateRectOptimization = value;\r\n    }\r\n\r\n    // Invalidated rectangle which is the combination of all invalidated controls after they have been rotated into absolute position\r\n    private _invalidatedRectangle: Nullable<Measure> = null;\r\n    /**\r\n     * Invalidates a rectangle area on the gui texture\r\n     * @param invalidMinX left most position of the rectangle to invalidate in the texture\r\n     * @param invalidMinY top most position of the rectangle to invalidate in the texture\r\n     * @param invalidMaxX right most position of the rectangle to invalidate in the texture\r\n     * @param invalidMaxY bottom most position of the rectangle to invalidate in the texture\r\n     */\r\n    public invalidateRect(invalidMinX: number, invalidMinY: number, invalidMaxX: number, invalidMaxY: number) {\r\n        if (!this._useInvalidateRectOptimization) {\r\n            return;\r\n        }\r\n        if (!this._invalidatedRectangle) {\r\n            this._invalidatedRectangle = new Measure(invalidMinX, invalidMinY, invalidMaxX - invalidMinX + 1, invalidMaxY - invalidMinY + 1);\r\n        } else {\r\n            // Compute intersection\r\n            const maxX = Math.ceil(Math.max(this._invalidatedRectangle.left + this._invalidatedRectangle.width - 1, invalidMaxX));\r\n            const maxY = Math.ceil(Math.max(this._invalidatedRectangle.top + this._invalidatedRectangle.height - 1, invalidMaxY));\r\n            this._invalidatedRectangle.left = Math.floor(Math.min(this._invalidatedRectangle.left, invalidMinX));\r\n            this._invalidatedRectangle.top = Math.floor(Math.min(this._invalidatedRectangle.top, invalidMinY));\r\n            this._invalidatedRectangle.width = maxX - this._invalidatedRectangle.left + 1;\r\n            this._invalidatedRectangle.height = maxY - this._invalidatedRectangle.top + 1;\r\n        }\r\n    }\r\n    /**\r\n     * Marks the texture as dirty forcing a complete update\r\n     */\r\n    public markAsDirty() {\r\n        this._isDirty = true;\r\n    }\r\n    /**\r\n     * Helper function used to create a new style\r\n     * @returns a new style\r\n     * @see https://doc.babylonjs.com/features/featuresDeepDive/gui/gui#styles\r\n     */\r\n    public createStyle(): Style {\r\n        return new Style(this);\r\n    }\r\n    /**\r\n     * Adds a new control to the root container\r\n     * @param control defines the control to add\r\n     * @returns the current texture\r\n     */\r\n    public addControl(control: Control): AdvancedDynamicTexture {\r\n        this._rootContainer.addControl(control);\r\n        return this;\r\n    }\r\n    /**\r\n     * Removes a control from the root container\r\n     * @param control defines the control to remove\r\n     * @returns the current texture\r\n     */\r\n    public removeControl(control: Control): AdvancedDynamicTexture {\r\n        this._rootContainer.removeControl(control);\r\n        return this;\r\n    }\r\n    /**\r\n     * Moves overlapped controls towards a position where it is not overlapping anymore.\r\n     * Please note that this method alters linkOffsetXInPixels and linkOffsetYInPixels.\r\n     * @param overlapGroup the overlap group which will be processed or undefined to process all overlap groups\r\n     * @param deltaStep the step size (speed) to reach the target non overlapping position (default 0.1)\r\n     * @param repelFactor how much is the control repelled by other controls\r\n     */\r\n    public moveToNonOverlappedPosition(overlapGroup?: number | Control[], deltaStep = 1, repelFactor = 1) {\r\n        let controlsForGroup: Control[];\r\n        if (Array.isArray(overlapGroup)) {\r\n            controlsForGroup = overlapGroup;\r\n        } else {\r\n            const descendants = this.getDescendants(true);\r\n            // get only the controls with an overlapGroup property set\r\n            // if the overlapGroup parameter is set, filter the controls and get only the controls belonging to that overlapGroup\r\n            controlsForGroup = overlapGroup === undefined ? descendants.filter((c) => c.overlapGroup !== undefined) : descendants.filter((c) => c.overlapGroup === overlapGroup);\r\n        }\r\n\r\n        for (const control1 of controlsForGroup) {\r\n            let velocity = Vector2.Zero();\r\n            const center = new Vector2(control1.centerX, control1.centerY);\r\n\r\n            for (const control2 of controlsForGroup) {\r\n                if (control1 !== control2 && AdvancedDynamicTexture._Overlaps(control1, control2)) {\r\n                    // if the two controls overlaps get a direction vector from one control's center to another control's center\r\n                    const diff = center.subtract(new Vector2(control2.centerX, control2.centerY));\r\n                    const diffLength = diff.length();\r\n\r\n                    if (diffLength > 0) {\r\n                        // calculate the velocity\r\n                        velocity = velocity.add(diff.normalize().scale(repelFactor / diffLength));\r\n                    }\r\n                }\r\n            }\r\n\r\n            if (velocity.length() > 0) {\r\n                // move the control along the direction vector away from the overlapping control\r\n                velocity = velocity.normalize().scale(deltaStep * (control1.overlapDeltaMultiplier ?? 1));\r\n                control1.linkOffsetXInPixels += velocity.x;\r\n                control1.linkOffsetYInPixels += velocity.y;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Release all resources\r\n     */\r\n    public override dispose(): void {\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        this._rootElement = null;\r\n        scene.onBeforeCameraRenderObservable.remove(this._renderObserver);\r\n        if (this._resizeObserver) {\r\n            scene.getEngine().onResizeObservable.remove(this._resizeObserver);\r\n        }\r\n        if (this._prePointerObserver) {\r\n            scene.onPrePointerObservable.remove(this._prePointerObserver);\r\n        }\r\n        if (this._sceneRenderObserver) {\r\n            scene.onBeforeRenderObservable.remove(this._sceneRenderObserver);\r\n        }\r\n        if (this._pointerObserver) {\r\n            scene.onPointerObservable.remove(this._pointerObserver);\r\n        }\r\n        if (this._preKeyboardObserver) {\r\n            scene.onPreKeyboardObservable.remove(this._preKeyboardObserver);\r\n        }\r\n        if (this._canvasPointerOutObserver) {\r\n            scene.getEngine().onCanvasPointerOutObservable.remove(this._canvasPointerOutObserver);\r\n        }\r\n        if (this._canvasBlurObserver) {\r\n            scene.getEngine().onCanvasBlurObservable.remove(this._canvasBlurObserver);\r\n        }\r\n        if (this._controlAddedObserver) {\r\n            this._rootContainer.onControlAddedObservable.remove(this._controlAddedObserver);\r\n        }\r\n        if (this._controlRemovedObserver) {\r\n            this._rootContainer.onControlRemovedObservable.remove(this._controlRemovedObserver);\r\n        }\r\n        if (this._layerToDispose) {\r\n            this._layerToDispose.texture = null;\r\n            this._layerToDispose.dispose();\r\n            this._layerToDispose = null;\r\n        }\r\n        this._rootContainer.dispose();\r\n        this.onClipboardObservable.clear();\r\n        this.onControlPickedObservable.clear();\r\n        this.onBeginRenderObservable.clear();\r\n        this.onEndRenderObservable.clear();\r\n        this.onBeginLayoutObservable.clear();\r\n        this.onEndLayoutObservable.clear();\r\n        this.onGuiReadyObservable.clear();\r\n        super.dispose();\r\n    }\r\n\r\n    private _alreadyRegisteredForRender = false;\r\n    private _onResize(): void {\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n        // Check size\r\n        const engine = scene.getEngine();\r\n        if (this.adjustToEngineHardwareScalingLevel) {\r\n            // force the renderScale to the engine's hardware scaling level\r\n            this._renderScale = engine.getHardwareScalingLevel();\r\n            // calculate the max renderScale, based on the max texture size of engine.getCaps().maxTextureSize (enforced by some mobile devices)\r\n            this._renderScale =\r\n                1 / Math.max(this._renderScale, engine.getRenderWidth() / engine.getCaps().maxTextureSize, engine.getRenderHeight() / engine.getCaps().maxTextureSize);\r\n        }\r\n        const textureSize = this.getSize();\r\n        let renderWidth = engine.getRenderWidth() * this._renderScale;\r\n        let renderHeight = engine.getRenderHeight() * this._renderScale;\r\n\r\n        if (this._renderAtIdealSize) {\r\n            if (this._idealWidth) {\r\n                renderHeight = (renderHeight * this._idealWidth) / renderWidth;\r\n                renderWidth = this._idealWidth;\r\n            } else if (this._idealHeight) {\r\n                renderWidth = (renderWidth * this._idealHeight) / renderHeight;\r\n                renderHeight = this._idealHeight;\r\n            }\r\n        }\r\n        if (textureSize.width !== renderWidth || textureSize.height !== renderHeight) {\r\n            this.scaleTo(renderWidth, renderHeight);\r\n            if (this.adjustToEngineHardwareScalingLevel) {\r\n                const engineRenderScale = 1 / engine.getHardwareScalingLevel();\r\n                const scale = this._renderScale * engineRenderScale;\r\n                this._rootContainer.scaleX = scale;\r\n                this._rootContainer.scaleY = scale;\r\n                this._rootContainer.widthInPixels = renderWidth / scale;\r\n                this._rootContainer.heightInPixels = renderHeight / scale;\r\n            }\r\n            this.markAsDirty();\r\n            if (this._idealWidth || this._idealHeight) {\r\n                this._rootContainer._markAllAsDirty();\r\n            }\r\n            if (!this._alreadyRegisteredForRender) {\r\n                this._alreadyRegisteredForRender = true;\r\n                Tools.SetImmediate(() => {\r\n                    // We want to force an update so the texture can be set as ready\r\n                    this.update(this.applyYInversionOnUpdate, this.premulAlpha, AdvancedDynamicTexture.AllowGPUOptimizations);\r\n                    this._alreadyRegisteredForRender = false;\r\n                });\r\n            }\r\n        }\r\n        this.invalidateRect(0, 0, textureSize.width - 1, textureSize.height - 1);\r\n    }\r\n    /** @internal */\r\n    public _getGlobalViewport(): Viewport {\r\n        const size = this.getSize();\r\n        const globalViewPort = this._fullscreenViewport.toGlobal(size.width, size.height);\r\n\r\n        const targetX = Math.round(globalViewPort.width / this._rootContainer.scaleX);\r\n        const targetY = Math.round(globalViewPort.height / this._rootContainer.scaleY);\r\n\r\n        const scale = this._adjustToEngineHardwareScalingLevel ? this._renderScale / (this.getScene()?.getEngine().getHardwareScalingLevel() || 1) : 1;\r\n\r\n        globalViewPort.x += (globalViewPort.width / scale - targetX) / 2;\r\n        globalViewPort.y += (globalViewPort.height / scale - targetY) / 2;\r\n\r\n        globalViewPort.width = targetX;\r\n        globalViewPort.height = targetY;\r\n\r\n        return globalViewPort;\r\n    }\r\n    /**\r\n     * Get screen coordinates for a vector3\r\n     * @param position defines the position to project\r\n     * @param worldMatrix defines the world matrix to use\r\n     * @returns the projected position\r\n     */\r\n    public getProjectedPosition(position: Vector3, worldMatrix: Matrix): Vector2 {\r\n        const result = this.getProjectedPositionWithZ(position, worldMatrix);\r\n        return new Vector2(result.x, result.y);\r\n    }\r\n\r\n    /**\r\n     * Get screen coordinates for a vector3\r\n     * @param position defines the position to project\r\n     * @param worldMatrix defines the world matrix to use\r\n     * @returns the projected position with Z\r\n     */\r\n    public getProjectedPositionWithZ(position: Vector3, worldMatrix: Matrix): Vector3 {\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return Vector3.Zero();\r\n        }\r\n        const globalViewport = this._getGlobalViewport();\r\n        const projectedPosition = Vector3.Project(position, worldMatrix, scene.getTransformMatrix(), globalViewport);\r\n        return new Vector3(projectedPosition.x, projectedPosition.y, projectedPosition.z);\r\n    }\r\n\r\n    /** @internal */\r\n    public _checkUpdate(camera: Nullable<Camera>, skipUpdate?: boolean): void {\r\n        if (this._layerToDispose && camera) {\r\n            if ((camera.layerMask & this._layerToDispose.layerMask) === 0) {\r\n                return;\r\n            }\r\n        }\r\n        if (this._isFullscreen && this._linkedControls.length) {\r\n            const scene = this.getScene();\r\n            if (!scene) {\r\n                return;\r\n            }\r\n            const globalViewport = this._getGlobalViewport();\r\n            for (const control of this._linkedControls) {\r\n                if (!control.isVisible) {\r\n                    continue;\r\n                }\r\n                const mesh = control._linkedMesh as AbstractMesh;\r\n                if (!mesh || mesh.isDisposed()) {\r\n                    Tools.SetImmediate(() => {\r\n                        control.linkWithMesh(null);\r\n                    });\r\n                    continue;\r\n                }\r\n                const position = mesh.getBoundingInfo ? mesh.getBoundingInfo().boundingSphere.center : (Vector3.ZeroReadOnly as Vector3);\r\n                const projectedPosition = Vector3.Project(position, mesh.getWorldMatrix(), scene.getTransformMatrix(), globalViewport);\r\n                if (projectedPosition.z < 0 || projectedPosition.z > 1) {\r\n                    control.notRenderable = true;\r\n                    continue;\r\n                }\r\n                control.notRenderable = false;\r\n                if (this.useInvalidateRectOptimization) {\r\n                    control.invalidateRect();\r\n                }\r\n\r\n                control._moveToProjectedPosition(projectedPosition);\r\n            }\r\n        }\r\n        if (!this._isDirty && !this._rootContainer.isDirty) {\r\n            return;\r\n        }\r\n        this._isDirty = false;\r\n        this._render(skipUpdate);\r\n        if (!skipUpdate) {\r\n            this.update(this.applyYInversionOnUpdate, this.premulAlpha, AdvancedDynamicTexture.AllowGPUOptimizations);\r\n        }\r\n    }\r\n\r\n    private _clearMeasure = new Measure(0, 0, 0, 0);\r\n\r\n    private _render(skipRender?: boolean): void {\r\n        const textureSize = this.getSize();\r\n        const renderWidth = textureSize.width;\r\n        const renderHeight = textureSize.height;\r\n\r\n        const context = this.getContext();\r\n        context.font = \"18px Arial\";\r\n        context.strokeStyle = \"white\";\r\n\r\n        if (this.onGuiReadyObservable.hasObservers()) {\r\n            this._checkGuiIsReady();\r\n        }\r\n\r\n        /** We have to recheck the camera projection in the case the root control's children have changed  */\r\n        if (this._rootChildrenHaveChanged) {\r\n            const camera = this.getScene()?.activeCamera;\r\n            if (camera) {\r\n                this._rootChildrenHaveChanged = false;\r\n                this._checkUpdate(camera, true);\r\n            }\r\n        }\r\n\r\n        // Layout\r\n        this.onBeginLayoutObservable.notifyObservers(this);\r\n        const measure = new Measure(0, 0, renderWidth, renderHeight);\r\n        this._numLayoutCalls = 0;\r\n        this._rootContainer._layout(measure, context);\r\n        this.onEndLayoutObservable.notifyObservers(this);\r\n        this._isDirty = false; // Restoring the dirty state that could have been set by controls during layout processing\r\n\r\n        if (skipRender) {\r\n            return;\r\n        }\r\n\r\n        // Clear\r\n        if (this._invalidatedRectangle) {\r\n            this._clearMeasure.copyFrom(this._invalidatedRectangle);\r\n        } else {\r\n            this._clearMeasure.copyFromFloats(0, 0, renderWidth, renderHeight);\r\n        }\r\n        context.clearRect(this._clearMeasure.left, this._clearMeasure.top, this._clearMeasure.width, this._clearMeasure.height);\r\n        if (this._background) {\r\n            context.save();\r\n            context.fillStyle = this._background;\r\n            context.fillRect(this._clearMeasure.left, this._clearMeasure.top, this._clearMeasure.width, this._clearMeasure.height);\r\n            context.restore();\r\n        }\r\n\r\n        // Render\r\n        this.onBeginRenderObservable.notifyObservers(this);\r\n        this._numRenderCalls = 0;\r\n        this._rootContainer._render(context, this._invalidatedRectangle);\r\n        this.onEndRenderObservable.notifyObservers(this);\r\n        this._invalidatedRectangle = null;\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public _changeCursor(cursor: string) {\r\n        if (this._rootElement) {\r\n            this._rootElement.style.cursor = cursor;\r\n            this._cursorChanged = true;\r\n        }\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public _registerLastControlDown(control: Control, pointerId: number) {\r\n        this._lastControlDown[pointerId] = control;\r\n        this.onControlPickedObservable.notifyObservers(control);\r\n    }\r\n    private _doPicking(x: number, y: number, pi: Nullable<PointerInfoBase>, type: number, pointerId: number, buttonIndex: number, deltaX?: number, deltaY?: number): void {\r\n        const scene = this.getScene();\r\n        if (!scene || this.disablePicking) {\r\n            return;\r\n        }\r\n        const engine = scene.getEngine();\r\n        const textureSize = this.getSize();\r\n        if (this._isFullscreen) {\r\n            const camera = scene.cameraToUseForPointers || scene.activeCamera;\r\n            if (!camera) {\r\n                return;\r\n            }\r\n            const viewport = camera.viewport;\r\n            x = x * (textureSize.width / (engine.getRenderWidth() * viewport.width));\r\n            y = y * (textureSize.height / (engine.getRenderHeight() * viewport.height));\r\n        }\r\n        if (this._capturingControl[pointerId]) {\r\n            if (this._capturingControl[pointerId].isPointerBlocker) {\r\n                this._shouldBlockPointer = true;\r\n            }\r\n            this._capturingControl[pointerId]._processObservables(type, x, y, pi, pointerId, buttonIndex);\r\n            return;\r\n        }\r\n\r\n        this._cursorChanged = false;\r\n        if (!this._rootContainer._processPicking(x, y, pi, type, pointerId, buttonIndex, deltaX, deltaY)) {\r\n            if (!scene.doNotHandleCursors) {\r\n                this._changeCursor(\"\");\r\n            }\r\n            if (type === PointerEventTypes.POINTERMOVE) {\r\n                if (this._lastControlOver[pointerId]) {\r\n                    this._lastControlOver[pointerId]._onPointerOut(this._lastControlOver[pointerId], pi);\r\n                    delete this._lastControlOver[pointerId];\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!this._cursorChanged && !scene.doNotHandleCursors) {\r\n            this._changeCursor(\"\");\r\n        }\r\n        this._manageFocus();\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public _cleanControlAfterRemovalFromList(list: { [pointerId: number]: Control }, control: Control) {\r\n        for (const pointerId in list) {\r\n            if (!Object.prototype.hasOwnProperty.call(list, pointerId)) {\r\n                continue;\r\n            }\r\n            const lastControlOver = list[pointerId];\r\n            if (lastControlOver === control) {\r\n                delete list[pointerId];\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * @internal\r\n     */\r\n    public _cleanControlAfterRemoval(control: Control) {\r\n        this._cleanControlAfterRemovalFromList(this._lastControlDown, control);\r\n        this._cleanControlAfterRemovalFromList(this._lastControlOver, control);\r\n    }\r\n\r\n    /**\r\n     * This function will run a pointer event on this ADT and will trigger any pointer events on any controls\r\n     * This will work on a fullscreen ADT only. For mesh based ADT, simulate pointer events using the scene directly.\r\n     * @param x pointer X on the canvas for the picking\r\n     * @param y pointer Y on the canvas for the picking\r\n     * @param pi optional pointer information\r\n     */\r\n    public pick(x: number, y: number, pi: Nullable<PointerInfoPre> = null) {\r\n        if (this._isFullscreen && this._scene) {\r\n            this._translateToPicking(this._scene, new Viewport(0, 0, 0, 0), pi, x, y);\r\n        }\r\n    }\r\n\r\n    private _translateToPicking(scene: Scene, tempViewport: Viewport, pi: Nullable<PointerInfoPre>, x: number = scene.pointerX, y: number = scene.pointerY) {\r\n        const camera = scene.cameraToUseForPointers || scene.activeCamera;\r\n        const engine = scene.getEngine();\r\n        const originalCameraToUseForPointers = scene.cameraToUseForPointers;\r\n\r\n        if (!camera) {\r\n            tempViewport.x = 0;\r\n            tempViewport.y = 0;\r\n            tempViewport.width = engine.getRenderWidth();\r\n            tempViewport.height = engine.getRenderHeight();\r\n        } else {\r\n            if (camera.rigCameras.length) {\r\n                // rig camera - we need to find the camera to use for this event\r\n                const rigViewport = new Viewport(0, 0, 1, 1);\r\n                for (const rigCamera of camera.rigCameras) {\r\n                    // generate the viewport of this camera\r\n                    rigCamera.viewport.toGlobalToRef(engine.getRenderWidth(), engine.getRenderHeight(), rigViewport);\r\n                    const transformedX = x / engine.getHardwareScalingLevel() - rigViewport.x;\r\n                    const transformedY = y / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - rigViewport.y - rigViewport.height);\r\n                    // check if the pointer is in the camera's viewport\r\n                    if (transformedX < 0 || transformedY < 0 || x > rigViewport.width || y > rigViewport.height) {\r\n                        // out of viewport - don't use this camera\r\n                        return;\r\n                    }\r\n                    // set the camera to use for pointers until this pointer loop is over\r\n                    scene.cameraToUseForPointers = rigCamera;\r\n                    // set the viewport\r\n                    tempViewport.x = rigViewport.x;\r\n                    tempViewport.y = rigViewport.y;\r\n                    tempViewport.width = rigViewport.width;\r\n                    tempViewport.height = rigViewport.height;\r\n                }\r\n            } else {\r\n                camera.viewport.toGlobalToRef(engine.getRenderWidth(), engine.getRenderHeight(), tempViewport);\r\n            }\r\n        }\r\n\r\n        const transformedX = x / engine.getHardwareScalingLevel() - tempViewport.x;\r\n        const transformedY = y / engine.getHardwareScalingLevel() - (engine.getRenderHeight() - tempViewport.y - tempViewport.height);\r\n        this._shouldBlockPointer = false;\r\n        // Do picking modifies _shouldBlockPointer\r\n        if (pi) {\r\n            const pointerId = (pi.event as IPointerEvent).pointerId || this._defaultMousePointerId;\r\n            this._doPicking(transformedX, transformedY, pi, pi.type, pointerId, pi.event.button, (<IWheelEvent>pi.event).deltaX, (<IWheelEvent>pi.event).deltaY);\r\n            // Avoid overwriting a true skipOnPointerObservable to false\r\n            if ((this._shouldBlockPointer && !(pi.type & this.skipBlockEvents)) || this._capturingControl[pointerId]) {\r\n                pi.skipOnPointerObservable = true;\r\n            }\r\n        } else {\r\n            this._doPicking(transformedX, transformedY, null, PointerEventTypes.POINTERMOVE, this._defaultMousePointerId, 0);\r\n        }\r\n        // if overridden by a rig camera - reset back to the original value\r\n        scene.cameraToUseForPointers = originalCameraToUseForPointers;\r\n    }\r\n\r\n    /** Attach to all scene events required to support pointer events */\r\n    public attach(): void {\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        const tempViewport = new Viewport(0, 0, 0, 0);\r\n\r\n        this._prePointerObserver = scene.onPrePointerObservable.add((pi) => {\r\n            if (\r\n                scene.isPointerCaptured((<IPointerEvent>pi.event).pointerId) &&\r\n                pi.type === PointerEventTypes.POINTERUP &&\r\n                !this._capturedPointerIds.has((pi.event as IPointerEvent).pointerId)\r\n            ) {\r\n                return;\r\n            }\r\n            if (\r\n                pi.type !== PointerEventTypes.POINTERMOVE &&\r\n                pi.type !== PointerEventTypes.POINTERUP &&\r\n                pi.type !== PointerEventTypes.POINTERDOWN &&\r\n                pi.type !== PointerEventTypes.POINTERWHEEL &&\r\n                pi.type !== PointerEventTypes.POINTERTAP\r\n            ) {\r\n                return;\r\n            }\r\n\r\n            if (pi.type === PointerEventTypes.POINTERMOVE) {\r\n                // Avoid pointerMove events firing while the pointer is captured by the scene\r\n                if (scene.isPointerCaptured((<IPointerEvent>pi.event).pointerId)) {\r\n                    return;\r\n                }\r\n                if ((pi.event as IPointerEvent).pointerId) {\r\n                    this._defaultMousePointerId = (pi.event as IPointerEvent).pointerId; // This is required to make sure we have the correct pointer ID for wheel\r\n                }\r\n            }\r\n            this._translateToPicking(scene, tempViewport, pi);\r\n        });\r\n        this._attachPickingToSceneRender(scene, () => this._translateToPicking(scene, tempViewport, null), false);\r\n        this._attachToOnPointerOut(scene);\r\n        this._attachToOnBlur(scene);\r\n    }\r\n\r\n    private _focusProperties: { index: number; total: number } = { index: 0, total: -1 };\r\n\r\n    private _focusNextElement(forward: boolean = true): void {\r\n        // generate the order of tab-able controls\r\n        const sortedTabbableControls: Control[] = [];\r\n        this.executeOnAllControls((control) => {\r\n            if (control.isFocusInvisible || !control.isVisible || control.tabIndex < 0) {\r\n                return;\r\n            }\r\n            sortedTabbableControls.push(control);\r\n        });\r\n        // if no control is tab-able, return\r\n        if (sortedTabbableControls.length === 0) {\r\n            return;\r\n        }\r\n        sortedTabbableControls.sort((a, b) => {\r\n            // if tabIndex is 0, put it in the end of the list, otherwise sort by tabIndex\r\n            return a.tabIndex === 0 ? 1 : b.tabIndex === 0 ? -1 : a.tabIndex - b.tabIndex;\r\n        });\r\n        this._focusProperties.total = sortedTabbableControls.length;\r\n        // if no control is focused, focus the first one\r\n        let nextIndex = -1;\r\n        if (!this._focusedControl) {\r\n            nextIndex = forward ? 0 : sortedTabbableControls.length - 1;\r\n        } else {\r\n            const currentIndex = sortedTabbableControls.indexOf(this._focusedControl);\r\n            nextIndex = currentIndex + (forward ? 1 : -1);\r\n            if (nextIndex < 0) {\r\n                nextIndex = sortedTabbableControls.length - 1;\r\n            } else if (nextIndex >= sortedTabbableControls.length) {\r\n                nextIndex = 0;\r\n            }\r\n        }\r\n        sortedTabbableControls[nextIndex].focus();\r\n        this._focusProperties.index = nextIndex;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     */\r\n    private _onClipboardCopy = (rawEvt: Event) => {\r\n        const evt = rawEvt as ClipboardEvent;\r\n        const ev = new ClipboardInfo(ClipboardEventTypes.COPY, evt);\r\n        this.onClipboardObservable.notifyObservers(ev);\r\n        evt.preventDefault();\r\n    };\r\n    /**\r\n     * @internal\r\n     */\r\n    private _onClipboardCut = (rawEvt: Event) => {\r\n        const evt = rawEvt as ClipboardEvent;\r\n        const ev = new ClipboardInfo(ClipboardEventTypes.CUT, evt);\r\n        this.onClipboardObservable.notifyObservers(ev);\r\n        evt.preventDefault();\r\n    };\r\n    /**\r\n     * @internal\r\n     */\r\n    private _onClipboardPaste = (rawEvt: Event) => {\r\n        const evt = rawEvt as ClipboardEvent;\r\n        const ev = new ClipboardInfo(ClipboardEventTypes.PASTE, evt);\r\n        this.onClipboardObservable.notifyObservers(ev);\r\n        evt.preventDefault();\r\n    };\r\n    /**\r\n     * Register the clipboard Events onto the canvas\r\n     */\r\n    public registerClipboardEvents(): void {\r\n        self.addEventListener(\"copy\", this._onClipboardCopy, false);\r\n        self.addEventListener(\"cut\", this._onClipboardCut, false);\r\n        self.addEventListener(\"paste\", this._onClipboardPaste, false);\r\n    }\r\n    /**\r\n     * Unregister the clipboard Events from the canvas\r\n     */\r\n    public unRegisterClipboardEvents(): void {\r\n        self.removeEventListener(\"copy\", this._onClipboardCopy);\r\n        self.removeEventListener(\"cut\", this._onClipboardCut);\r\n        self.removeEventListener(\"paste\", this._onClipboardPaste);\r\n    }\r\n\r\n    /**\r\n     * Transform uvs from mesh space to texture space, taking the texture into account\r\n     * @param uv the uvs in mesh space\r\n     * @returns the uvs in texture space\r\n     */\r\n    private _transformUvs(uv: Vector2): Vector2 {\r\n        const textureMatrix = this.getTextureMatrix();\r\n        let result;\r\n        if (textureMatrix.isIdentityAs3x2()) {\r\n            result = uv;\r\n        } else {\r\n            const homogeneousTextureMatrix = TmpVectors.Matrix[0];\r\n\r\n            textureMatrix.getRowToRef(0, TmpVectors.Vector4[0]);\r\n            textureMatrix.getRowToRef(1, TmpVectors.Vector4[1]);\r\n            textureMatrix.getRowToRef(2, TmpVectors.Vector4[2]);\r\n\r\n            const r0 = TmpVectors.Vector4[0];\r\n            const r1 = TmpVectors.Vector4[1];\r\n            const r2 = TmpVectors.Vector4[2];\r\n\r\n            homogeneousTextureMatrix.setRowFromFloats(0, r0.x, r0.y, 0, 0);\r\n            homogeneousTextureMatrix.setRowFromFloats(1, r1.x, r1.y, 0, 0);\r\n            homogeneousTextureMatrix.setRowFromFloats(2, 0, 0, 1, 0);\r\n            homogeneousTextureMatrix.setRowFromFloats(3, r2.x, r2.y, 0, 1);\r\n\r\n            result = TmpVectors.Vector2[0];\r\n            Vector2.TransformToRef(uv, homogeneousTextureMatrix, result);\r\n        }\r\n\r\n        // In wrap and mirror mode, the texture coordinate for coordinates more than 1 is the fractional part of the coordinate\r\n        if (this.wrapU === Texture.WRAP_ADDRESSMODE || this.wrapU === Texture.MIRROR_ADDRESSMODE) {\r\n            if (result.x > 1) {\r\n                let fX = result.x - Math.trunc(result.x);\r\n                // In mirror mode, the sign of the texture coordinate depends on the integer part -\r\n                // odd integers means it is mirrored from the original coordinate\r\n                if (this.wrapU === Texture.MIRROR_ADDRESSMODE && Math.trunc(result.x) % 2 === 1) {\r\n                    fX = 1 - fX;\r\n                }\r\n                result.x = fX;\r\n            }\r\n        }\r\n        if (this.wrapV === Texture.WRAP_ADDRESSMODE || this.wrapV === Texture.MIRROR_ADDRESSMODE) {\r\n            if (result.y > 1) {\r\n                let fY = result.y - Math.trunc(result.y);\r\n                if (this.wrapV === Texture.MIRROR_ADDRESSMODE && Math.trunc(result.x) % 2 === 1) {\r\n                    fY = 1 - fY;\r\n                }\r\n                result.y = fY;\r\n            }\r\n        }\r\n        return result;\r\n    }\r\n    /**\r\n     * Connect the texture to a hosting mesh to enable interactions\r\n     * @param mesh defines the mesh to attach to\r\n     * @param supportPointerMove defines a boolean indicating if pointer move events must be catched as well\r\n     */\r\n    public attachToMesh(mesh: AbstractMesh, supportPointerMove = true): void {\r\n        const scene = this.getScene();\r\n        if (!scene) {\r\n            return;\r\n        }\r\n\r\n        if (this._pointerObserver) {\r\n            scene.onPointerObservable.remove(this._pointerObserver);\r\n        }\r\n\r\n        this._pointerObserver = scene.onPointerObservable.add((pi) => {\r\n            if (\r\n                pi.type !== PointerEventTypes.POINTERMOVE &&\r\n                pi.type !== PointerEventTypes.POINTERUP &&\r\n                pi.type !== PointerEventTypes.POINTERDOWN &&\r\n                pi.type !== PointerEventTypes.POINTERWHEEL\r\n            ) {\r\n                return;\r\n            }\r\n\r\n            if (pi.type === PointerEventTypes.POINTERMOVE && (pi.event as IPointerEvent).pointerId) {\r\n                this._defaultMousePointerId = (pi.event as IPointerEvent).pointerId; // This is required to make sure we have the correct pointer ID for wheel\r\n            }\r\n\r\n            const pointerId = (pi.event as IPointerEvent).pointerId || this._defaultMousePointerId;\r\n            if (pi.pickInfo && pi.pickInfo.hit && pi.pickInfo.pickedMesh === mesh) {\r\n                let uv = pi.pickInfo.getTextureCoordinates();\r\n                if (uv) {\r\n                    uv = this._transformUvs(uv);\r\n                    const size = this.getSize();\r\n                    this._doPicking(\r\n                        uv.x * size.width,\r\n                        (this.applyYInversionOnUpdate ? 1.0 - uv.y : uv.y) * size.height,\r\n                        pi,\r\n                        pi.type,\r\n                        pointerId,\r\n                        pi.event.button,\r\n                        (<IWheelEvent>pi.event).deltaX,\r\n                        (<IWheelEvent>pi.event).deltaY\r\n                    );\r\n                }\r\n            } else if (pi.type === PointerEventTypes.POINTERUP) {\r\n                if (this._lastControlDown[pointerId]) {\r\n                    this._lastControlDown[pointerId]._forcePointerUp(pointerId);\r\n                }\r\n                delete this._lastControlDown[pointerId];\r\n                if (this.focusedControl) {\r\n                    const friendlyControls = this.focusedControl.keepsFocusWith();\r\n                    let canMoveFocus = true;\r\n                    if (friendlyControls) {\r\n                        for (const control of friendlyControls) {\r\n                            // Same host, no need to keep the focus\r\n                            if (this === control._host) {\r\n                                continue;\r\n                            }\r\n                            // Different hosts\r\n                            const otherHost = control._host;\r\n                            if (otherHost._lastControlOver[pointerId] && otherHost._lastControlOver[pointerId].isAscendant(control)) {\r\n                                canMoveFocus = false;\r\n                                break;\r\n                            }\r\n                        }\r\n                    }\r\n                    if (canMoveFocus) {\r\n                        this.focusedControl = null;\r\n                    }\r\n                }\r\n            } else if (pi.type === PointerEventTypes.POINTERMOVE) {\r\n                if (this._lastControlOver[pointerId]) {\r\n                    this._lastControlOver[pointerId]._onPointerOut(this._lastControlOver[pointerId], pi, true);\r\n                }\r\n                delete this._lastControlOver[pointerId];\r\n            }\r\n        });\r\n        mesh.enablePointerMoveEvents = supportPointerMove;\r\n        this._attachPickingToSceneRender(\r\n            scene,\r\n            () => {\r\n                const pointerId = this._defaultMousePointerId;\r\n                const pick = scene?.pick(scene.pointerX, scene.pointerY);\r\n                if (pick && pick.hit && pick.pickedMesh === mesh) {\r\n                    let uv = pick.getTextureCoordinates();\r\n                    if (uv) {\r\n                        uv = this._transformUvs(uv);\r\n                        const size = this.getSize();\r\n                        this._doPicking(uv.x * size.width, (this.applyYInversionOnUpdate ? 1.0 - uv.y : uv.y) * size.height, null, PointerEventTypes.POINTERMOVE, pointerId, 0);\r\n                    }\r\n                } else {\r\n                    if (this._lastControlOver[pointerId]) {\r\n                        this._lastControlOver[pointerId]._onPointerOut(this._lastControlOver[pointerId], null, true);\r\n                    }\r\n                    delete this._lastControlOver[pointerId];\r\n                }\r\n            },\r\n            true\r\n        );\r\n        this._attachToOnPointerOut(scene);\r\n        this._attachToOnBlur(scene);\r\n    }\r\n    /**\r\n     * Move the focus to a specific control\r\n     * @param control defines the control which will receive the focus\r\n     */\r\n    public moveFocusToControl(control: Control): void {\r\n        this.focusedControl = control;\r\n        this._lastPickedControl = <any>control;\r\n        this._blockNextFocusCheck = true;\r\n    }\r\n    private _manageFocus(): void {\r\n        if (this._blockNextFocusCheck) {\r\n            this._blockNextFocusCheck = false;\r\n            this._lastPickedControl = <any>this._focusedControl;\r\n            return;\r\n        }\r\n        // Focus management\r\n        if (this._focusedControl) {\r\n            if (this._focusedControl !== <any>this._lastPickedControl) {\r\n                if (this._lastPickedControl.isFocusInvisible) {\r\n                    return;\r\n                }\r\n                this.focusedControl = null;\r\n            }\r\n        }\r\n    }\r\n    private _attachPickingToSceneRender(scene: Scene, pickFunction: () => void, forcePicking: boolean) {\r\n        this._sceneRenderObserver = scene.onBeforeRenderObservable.add(() => {\r\n            if (!this.checkPointerEveryFrame) {\r\n                return;\r\n            }\r\n            if (this._linkedControls.length > 0 || forcePicking) {\r\n                pickFunction();\r\n            }\r\n        });\r\n    }\r\n    private _attachToOnPointerOut(scene: Scene): void {\r\n        this._canvasPointerOutObserver = scene.getEngine().onCanvasPointerOutObservable.add((pointerEvent) => {\r\n            if (this._lastControlOver[pointerEvent.pointerId]) {\r\n                this._lastControlOver[pointerEvent.pointerId]._onPointerOut(this._lastControlOver[pointerEvent.pointerId], null);\r\n            }\r\n            delete this._lastControlOver[pointerEvent.pointerId];\r\n            if (this._lastControlDown[pointerEvent.pointerId] && this._lastControlDown[pointerEvent.pointerId] !== this._capturingControl[pointerEvent.pointerId]) {\r\n                this._lastControlDown[pointerEvent.pointerId]._forcePointerUp(pointerEvent.pointerId);\r\n                delete this._lastControlDown[pointerEvent.pointerId];\r\n            }\r\n        });\r\n    }\r\n    private _attachToOnBlur(scene: Scene): void {\r\n        this._canvasBlurObserver = scene.getEngine().onCanvasBlurObservable.add(() => {\r\n            Object.entries(this._lastControlDown).forEach(([, value]) => {\r\n                value._onCanvasBlur();\r\n            });\r\n            this.focusedControl = null;\r\n            this._lastControlDown = {};\r\n        });\r\n    }\r\n\r\n    /**\r\n     * Serializes the entire GUI system\r\n     * @returns an object with the JSON serialized data\r\n     */\r\n    public serializeContent(): any {\r\n        const size = this.getSize();\r\n        const serializationObject = {\r\n            root: {},\r\n            width: size.width,\r\n            height: size.height,\r\n        };\r\n\r\n        this._rootContainer.serialize(serializationObject.root);\r\n\r\n        return serializationObject;\r\n    }\r\n\r\n    /**\r\n     * Recreate the content of the ADT from a JSON object\r\n     * @param serializedObject define the JSON serialized object to restore from\r\n     * @param scaleToSize defines whether to scale to texture to the saved size\r\n     * @param urlRewriter defines an url rewriter to update urls before sending them to the controls\r\n     */\r\n    public parseSerializedObject(serializedObject: any, scaleToSize?: boolean, urlRewriter?: (url: string) => string) {\r\n        this._rootContainer = Control.Parse(serializedObject.root, this, urlRewriter) as Container;\r\n        if (scaleToSize) {\r\n            const width = serializedObject.width;\r\n            const height = serializedObject.height;\r\n            if (typeof width === \"number\" && typeof height === \"number\" && width >= 0 && height >= 0) {\r\n                this.scaleTo(width, height);\r\n            } else {\r\n                // scales the GUI to a default size if none was available in the serialized content\r\n                this.scaleTo(1920, 1080);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Clones the ADT. If no mesh is defined, the GUI will be considered as a fullscreen GUI\r\n     * @param newName defines the name of the new ADT\r\n     * @param attachToMesh defines if the new ADT should be attached to a mesh\r\n     * @returns the clone of the ADT\r\n     */\r\n    public override clone(newName?: string, attachToMesh?: AbstractMesh): AdvancedDynamicTexture {\r\n        const scene = this.getScene();\r\n\r\n        if (!scene) {\r\n            return this;\r\n        }\r\n        const size = this.getSize();\r\n        const data = this.serializeContent();\r\n        let clone;\r\n        if (!this._isFullscreen) {\r\n            if (attachToMesh) {\r\n                clone = AdvancedDynamicTexture.CreateForMesh(attachToMesh, size.width, size.height);\r\n            } else {\r\n                clone = new AdvancedDynamicTexture(newName ?? \"Clone of \" + this.name, size.width, size.height, scene, !this.noMipmap, this.samplingMode);\r\n            }\r\n        } else {\r\n            clone = AdvancedDynamicTexture.CreateFullscreenUI(newName ?? \"Clone of \" + this.name);\r\n        }\r\n        clone.parseSerializedObject(data);\r\n\r\n        return clone;\r\n    }\r\n\r\n    /**\r\n     * Recreate the content of the ADT from a JSON object\r\n     * @param serializedObject define the JSON serialized object to restore from\r\n     * @param scaleToSize defines whether to scale to texture to the saved size\r\n     * @param urlRewriter defines an url rewriter to update urls before sending them to the controls\r\n     * @deprecated Please use parseSerializedObject instead\r\n     */\r\n    public parseContent = this.parseSerializedObject;\r\n\r\n    /**\r\n     * Recreate the content of the ADT from a snippet saved by the GUI editor\r\n     * @param snippetId defines the snippet to load\r\n     * @param scaleToSize defines whether to scale to texture to the saved size\r\n     * @param appendToAdt if provided the snippet will be appended to the adt. Otherwise a fullscreen ADT will be created.\r\n     * @param urlRewriter defines an url rewriter to update urls before sending them to the controls\r\n     * @returns a promise that will resolve on success\r\n     */\r\n    public static async ParseFromSnippetAsync(\r\n        snippetId: string,\r\n        scaleToSize?: boolean,\r\n        appendToAdt?: AdvancedDynamicTexture,\r\n        urlRewriter?: (url: string) => string\r\n    ): Promise<AdvancedDynamicTexture> {\r\n        const adt = appendToAdt ?? AdvancedDynamicTexture.CreateFullscreenUI(\"ADT from snippet\");\r\n        if (snippetId === \"_BLANK\") {\r\n            return adt;\r\n        }\r\n\r\n        const serialized = await AdvancedDynamicTexture._LoadURLContentAsync(AdvancedDynamicTexture.SnippetUrl + \"/\" + snippetId.replace(/#/g, \"/\"), true);\r\n        adt.parseSerializedObject(serialized, scaleToSize, urlRewriter);\r\n        return adt;\r\n    }\r\n\r\n    /**\r\n     * Recreate the content of the ADT from a snippet saved by the GUI editor\r\n     * @param snippetId defines the snippet to load\r\n     * @param scaleToSize defines whether to scale to texture to the saved size\r\n     * @param urlRewriter defines an url rewriter to update urls before sending them to the controls\r\n     * @returns a promise that will resolve on success\r\n     */\r\n    public async parseFromSnippetAsync(snippetId: string, scaleToSize?: boolean, urlRewriter?: (url: string) => string): Promise<AdvancedDynamicTexture> {\r\n        return await AdvancedDynamicTexture.ParseFromSnippetAsync(snippetId, scaleToSize, this, urlRewriter);\r\n    }\r\n\r\n    /**\r\n     * Recreate the content of the ADT from a url json\r\n     * @param url defines the url to load\r\n     * @param scaleToSize defines whether to scale to texture to the saved size\r\n     * @param appendToAdt if provided the snippet will be appended to the adt. Otherwise a fullscreen ADT will be created.\r\n     * @param urlRewriter defines an url rewriter to update urls before sending them to the controls\r\n     * @returns a promise that will resolve on success\r\n     */\r\n    public static async ParseFromFileAsync(\r\n        url: string,\r\n        scaleToSize?: boolean,\r\n        appendToAdt?: AdvancedDynamicTexture,\r\n        urlRewriter?: (url: string) => string\r\n    ): Promise<AdvancedDynamicTexture> {\r\n        const adt = appendToAdt ?? AdvancedDynamicTexture.CreateFullscreenUI(\"ADT from URL\");\r\n        const serialized = await AdvancedDynamicTexture._LoadURLContentAsync(url);\r\n        adt.parseSerializedObject(serialized, scaleToSize, urlRewriter);\r\n        return adt;\r\n    }\r\n\r\n    /**\r\n     * Recreate the content of the ADT from a url json\r\n     * @param url defines the url to load\r\n     * @param scaleToSize defines whether to scale to texture to the saved size\r\n     * @param urlRewriter defines an url rewriter to update urls before sending them to the controls\r\n     * @returns a promise that will resolve on success\r\n     */\r\n    public async parseFromURLAsync(url: string, scaleToSize?: boolean, urlRewriter?: (url: string) => string): Promise<AdvancedDynamicTexture> {\r\n        return await AdvancedDynamicTexture.ParseFromFileAsync(url, scaleToSize, this, urlRewriter);\r\n    }\r\n\r\n    private static async _LoadURLContentAsync(url: string, snippet: boolean = false): Promise<any> {\r\n        if (url === \"\") {\r\n            throw new Error(\"No URL provided\");\r\n        }\r\n\r\n        return await new Promise((resolve, reject) => {\r\n            const request = new WebRequest();\r\n            request.addEventListener(\"readystatechange\", () => {\r\n                if (request.readyState == 4) {\r\n                    if (request.status == 200) {\r\n                        let gui;\r\n                        if (snippet) {\r\n                            const payload = JSON.parse(JSON.parse(request.responseText).jsonPayload);\r\n                            gui = payload.encodedGui ? new TextDecoder(\"utf-8\").decode(DecodeBase64ToBinary(payload.encodedGui)) : payload.gui;\r\n                        } else {\r\n                            gui = request.responseText;\r\n                        }\r\n                        const serializationObject = JSON.parse(gui);\r\n                        resolve(serializationObject);\r\n                    } else {\r\n                        // eslint-disable-next-line @typescript-eslint/prefer-promise-reject-errors\r\n                        reject(\"Unable to load\");\r\n                    }\r\n                }\r\n            });\r\n            request.open(\"GET\", url);\r\n            request.send();\r\n        });\r\n    }\r\n\r\n    // Statics\r\n    /**\r\n     * Compares two rectangle based controls for pixel overlap\r\n     * @param control1 The first control to compare\r\n     * @param control2 The second control to compare\r\n     * @returns true if overlaps, otherwise false\r\n     */\r\n    private static _Overlaps(control1: Control, control2: Control) {\r\n        return !(\r\n            control1.centerX > control2.centerX + control2.widthInPixels ||\r\n            control1.centerX + control1.widthInPixels < control2.centerX ||\r\n            control1.centerY + control1.heightInPixels < control2.centerY ||\r\n            control1.centerY > control2.centerY + control2.heightInPixels\r\n        );\r\n    }\r\n\r\n    /**\r\n     * Creates a new AdvancedDynamicTexture in projected mode (ie. attached to a mesh)\r\n     * @param mesh defines the mesh which will receive the texture\r\n     * @param width defines the texture width (1024 by default)\r\n     * @param height defines the texture height (1024 by default)\r\n     * @param supportPointerMove defines a boolean indicating if the texture must capture move events (true by default)\r\n     * @param onlyAlphaTesting defines a boolean indicating that alpha blending will not be used (only alpha testing) (false by default)\r\n     * @param invertY defines if the texture needs to be inverted on the y axis during loading (true by default)\r\n     * @param materialSetupCallback defines a custom way of creating and setting up the material on the mesh\r\n     * @param sampling defines the texture sampling mode (Texture.TRILINEAR_SAMPLINGMODE by default)\r\n     * @returns a new AdvancedDynamicTexture\r\n     */\r\n    public static CreateForMesh(\r\n        mesh: AbstractMesh,\r\n        width = 1024,\r\n        height = 1024,\r\n        supportPointerMove = true,\r\n        onlyAlphaTesting = false,\r\n        invertY?: boolean,\r\n        materialSetupCallback: (mesh: AbstractMesh, uniqueId: string, texture: AdvancedDynamicTexture, onlyAlphaTesting: boolean) => void = this._CreateMaterial,\r\n        sampling = Texture.TRILINEAR_SAMPLINGMODE\r\n    ): AdvancedDynamicTexture {\r\n        // use a unique ID in name so serialization will work even if you create two ADTs for a single mesh\r\n        const uniqueId = RandomGUID();\r\n        const result = new AdvancedDynamicTexture(`AdvancedDynamicTexture for ${mesh.name} [${uniqueId}]`, width, height, mesh.getScene(), true, sampling, invertY);\r\n\r\n        materialSetupCallback(mesh, uniqueId, result, onlyAlphaTesting);\r\n\r\n        result.attachToMesh(mesh, supportPointerMove);\r\n        return result;\r\n    }\r\n\r\n    private static _CreateMaterial(mesh: AbstractMesh, uniqueId: string, texture: AdvancedDynamicTexture, onlyAlphaTesting: boolean): void {\r\n        const internalClassType = GetClass(\"BABYLON.StandardMaterial\");\r\n        if (!internalClassType) {\r\n            // eslint-disable-next-line no-throw-literal\r\n            throw \"StandardMaterial needs to be imported before as it contains a side-effect required by your code.\";\r\n        }\r\n\r\n        const material: StandardMaterial = new internalClassType(`AdvancedDynamicTextureMaterial for ${mesh.name} [${uniqueId}]`, mesh.getScene());\r\n        material.backFaceCulling = false;\r\n        material.diffuseColor = Color3.Black();\r\n        material.specularColor = Color3.Black();\r\n        if (onlyAlphaTesting) {\r\n            material.diffuseTexture = texture;\r\n            material.emissiveTexture = texture;\r\n            texture.hasAlpha = true;\r\n        } else {\r\n            material.emissiveTexture = texture;\r\n            material.opacityTexture = texture;\r\n        }\r\n        mesh.material = material;\r\n    }\r\n\r\n    /**\r\n     * Creates a new AdvancedDynamicTexture in projected mode (ie. attached to a mesh) BUT do not create a new material for the mesh. You will be responsible for connecting the texture\r\n     * @param mesh defines the mesh which will receive the texture\r\n     * @param width defines the texture width (1024 by default)\r\n     * @param height defines the texture height (1024 by default)\r\n     * @param supportPointerMove defines a boolean indicating if the texture must capture move events (true by default)\r\n     * @param invertY defines if the texture needs to be inverted on the y axis during loading (true by default)\r\n     * @param sampling defines the texture sampling mode (Texture.TRILINEAR_SAMPLINGMODE by default)\r\n     * @returns a new AdvancedDynamicTexture\r\n     */\r\n    public static CreateForMeshTexture(\r\n        mesh: AbstractMesh,\r\n        width = 1024,\r\n        height = 1024,\r\n        supportPointerMove = true,\r\n        invertY?: boolean,\r\n        sampling = Texture.TRILINEAR_SAMPLINGMODE\r\n    ): AdvancedDynamicTexture {\r\n        const result = new AdvancedDynamicTexture(mesh.name + \" AdvancedDynamicTexture\", width, height, mesh.getScene(), true, sampling, invertY);\r\n        result.attachToMesh(mesh, supportPointerMove);\r\n        return result;\r\n    }\r\n    /**\r\n     * Creates a new AdvancedDynamicTexture in fullscreen mode.\r\n     * In this mode the texture will rely on a layer for its rendering.\r\n     * This allows it to be treated like any other layer.\r\n     * As such, if you have a multi camera setup, you can set the layerMask on the GUI as well.\r\n     * LayerMask is set through advancedTexture.layer.layerMask\r\n     * @param name defines name for the texture\r\n     * @param foreground defines a boolean indicating if the texture must be rendered in foreground (default is true)\r\n     * @param sceneOrOptions defines the hosting scene or options (IAdvancedDynamicTextureOptions)\r\n     * @param sampling defines the texture sampling mode (Texture.BILINEAR_SAMPLINGMODE by default)\r\n     * @param adaptiveScaling defines whether to automatically scale root to match hardwarescaling (false by default)\r\n     * @returns a new AdvancedDynamicTexture\r\n     */\r\n    public static CreateFullscreenUI(\r\n        name: string,\r\n        foreground: boolean = true,\r\n        sceneOrOptions: Nullable<Scene> | IAdvancedDynamicTextureOptions = null,\r\n        sampling = Texture.BILINEAR_SAMPLINGMODE,\r\n        adaptiveScaling: boolean = false\r\n    ): AdvancedDynamicTexture {\r\n        const isScene = !sceneOrOptions || (sceneOrOptions as Scene)._isScene;\r\n        const result = isScene\r\n            ? new AdvancedDynamicTexture(name, 0, 0, sceneOrOptions as Scene, false, sampling)\r\n            : new AdvancedDynamicTexture(name, sceneOrOptions as IAdvancedDynamicTextureOptions);\r\n        // Display\r\n        const resultScene = result.getScene();\r\n        const layer = new Layer(name + \"_layer\", null, resultScene, !foreground);\r\n        layer.texture = result;\r\n        result._layerToDispose = layer;\r\n        result._isFullscreen = true;\r\n\r\n        if (result.useStandalone) {\r\n            // Make sure the layer is not rendered by the layer component!\r\n            layer.layerMask = 0;\r\n        }\r\n\r\n        result.adjustToEngineHardwareScalingLevel = adaptiveScaling;\r\n\r\n        // Attach\r\n        result.attach();\r\n        return result;\r\n    }\r\n\r\n    /**\r\n     * Scales the texture\r\n     * @param ratio the scale factor to apply to both width and height\r\n     */\r\n    public override scale(ratio: number): void {\r\n        super.scale(ratio);\r\n        this.markAsDirty();\r\n    }\r\n\r\n    /**\r\n     * Resizes the texture\r\n     * @param width the new width\r\n     * @param height the new height\r\n     */\r\n    public override scaleTo(width: number, height: number): void {\r\n        super.scaleTo(width, height);\r\n        this.markAsDirty();\r\n    }\r\n\r\n    private _checkGuiIsReady() {\r\n        if (this.guiIsReady()) {\r\n            this.onGuiReadyObservable.notifyObservers(this);\r\n\r\n            this.onGuiReadyObservable.clear();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @returns true if all the GUI components are ready to render\r\n     */\r\n    public guiIsReady(): boolean {\r\n        return this._rootContainer.isReady();\r\n    }\r\n}\r\n"],
  "mappings": "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",
  "names": ["transformedX", "transformedY"]
}
